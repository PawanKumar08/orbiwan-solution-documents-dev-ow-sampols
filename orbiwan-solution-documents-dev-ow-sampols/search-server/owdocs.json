[{"objectID":"getting-started-login","hierarchy_lvl0":"Documentation","hierarchy_lvl1":"Getting Started","hierarchy_lvl2":"Login","content":" Login After the signup, you must have received an email with a one-time-usable-link to create your password. You can login on the instance URL mentioned in the email. The following screenshot shows how the login page looks like:  Once you Sign in, you will see the Welcome page of OrbiWAN with the applicable menu, as shown in the image below: ","url":"GettingStarted.html","anchor":"login"},{"objectID":"getting-started-add-gateway","hierarchy_lvl0":"Documentation","hierarchy_lvl1":"Getting Started","hierarchy_lvl2":"Add Gateway","content":" Add Gateway In order to register your gateway(s) on the applicable OrbiWAN instance, you can proceed with the following simple steps: \n  Navigate to Gateways menu –&gt; Add Gateways.\n  Enter the Gateway name and Select the model.\n  Copy the command provide in Installation box to provision the gateway.\n  Login to the gateway using SSH and paste the copied command in the gateway shell.\n  This command will download the Gateway Software and install on the Gateway.\n  Once the Software is installed, Reboot the gateway.\n  You can also watch the video to see the gateway registration process in action: \n    \n    Your browser does not support HTML video.\n Once the gateway reboots it will come online in around 1-2 min, after which you will see the status as OK in the gateways dashboard as shown in the Figure below: ","url":"GettingStarted.html","anchor":"add-gateway"},{"objectID":"getting-started-add-device","hierarchy_lvl0":"Documentation","hierarchy_lvl1":"Getting Started","hierarchy_lvl2":"Add Device","content":" Add Device The Next step after registering your gateways is to register your devices. The devices can be registered via as OTAA (Over The Air Activation) or ABP (Activation by Personalization) activation mode. Below are the steps to add a device to your account: \n  Navigate to  Devices –&gt; Manage Devices –&gt; Add devices.\n  \n  An Add Device window will popup, enter the DevEUI, and an optional Comment.\n  Select the Device Profile and Service Profile from the drop-down menu as seen below:\n  \n  To add Device via OTAA Activation mode, choose the Device Profile created for OTAA mode and enter the AppKey.\n  To add Device via ABP Activation mode, choose the Device Profile created for ABP mode and enter the DevAddr, Nwkskey and Appskey\n    \n      Choose the applicable LoRaWAN Class either A or B or C\n      Select the Activated option as Yes - this will enable the device to operate on the Network.\n    \n  \n  \n  Then click OK. The device will be registered as seen below:\n  As soon as you’re done with registering your devices and gateways, you will be able to see each device send a join request to the network. Once the device joins the network, it can start sending the uplink messages. You can see each device’s payloads in Devices –&gt; Select your device –&gt; Action –&gt; View Data.  Clicking on the View Data button will open the Device Activity page where you can see all of the uplink and downlink messages of the selected device.  You can also watch the videos below to see the device registration process in action: Device Join via ABP Activation Mode \n    \n    Your browser does not support HTML video.\n Device Join via OTAA Activation Mode \n    \n    Your browser does not support HTML video.\n","url":"GettingStarted.html","anchor":"add-device"},{"objectID":"getting-started-add-application","hierarchy_lvl0":"Documentation","hierarchy_lvl1":"Getting Started","hierarchy_lvl2":"Add Application","content":" Add Application OrbiWAN offers you an option to push all uplinks to your designated application. To enable this feature, you need to add an application inside OrbiWAN. Once an application is in place and attached to a particular device, all this device’s payloads will be pushed to the particular application. To add an application follow the simple steps below: \n  Navigate to the Applications menu –&gt; Add Application\n  This will open Manage App which allows you to add an application.\n  You need to enter an Account ID.\n  The Push Settings tab allows the user to directly configure the application account to make push notification to the external application. Push notification are sent to an HTTP(S) server, the hostname and port number must be entered. The screenshot below shows the available fields for push the settings form.  As seen in the screenshot: \n  The Hostname is the DNS or IP of the external HTTP/HTTPS application.\n  The Port must be entered if external application is using specific port.\n  The Path prefix is the external application URL where the packets to be pushed, i.e /app2/ul/data from application URL (https://app.orbiwise.com/app2/ul/data)\n  In case the external application supports Authentication, OrbiWAN can be configured to use it to make connections.\n Once you’re done adding the application, You need to start the application via Action –&gt; Start Push which will start pushing all the payloads to the application.  Although you have added the application it will only receive the data once the application is assigned to the device(s). The next section will help you to assign application to devices.","url":"GettingStarted.html","anchor":"add-application"},{"objectID":"getting-started-assign-application","hierarchy_lvl0":"Documentation","hierarchy_lvl1":"Getting Started","hierarchy_lvl2":"Assign Application","content":" Assign Application Once you have created an application account, you need to assign this application to the particular device(s) this application is assigned to: \n  Navigate to Devices -&gt; Action -&gt; App Assignment\n  \n  Select the created Application\n  Click on Add button as below:\n   Once your application is assigned to the device, OrbiWAN will start pushing the real time traffic to your assigned application. You can also watch the following video to see the Application Management process in action: Application Management \n    \n    Your browser does not support HTML video.\n Thats all! Your network and traffic should be up and running fine now!!!","url":"GettingStarted.html","anchor":"assign-application"},{"objectID":"application-management-creating-application-from-ui","hierarchy_lvl0":"Documentation","hierarchy_lvl1":"Application Management","hierarchy_lvl2":"Creating Application From UI","content":" Creating Application From UI For creating the application using UI user can Login to UI (as user or customer then) \n  Go to Applications tab\n  Click on Add Application. Pressing the Add Application button brings up the following Manage Apps window for user to enter the details of the application account.\n The account can be assigned with a sub-set of the rights of the users account and add the payload push settings for HTTP/HTTPS interface.  Push Settings tab allows the user to directly configure the application account to make push notification to the external application Push notification are sent to a HTTP(S) server and the hostname and port must be entered. An option path prefix can be specified too as can the optional access credential that the OrbiWAN will use to make the connection to the application. The Hostname is DNS or IP of the HTTP/HTTPS application.\nThe Port must be entered if application is using specific port.\nThe Path prefix is the application URL where the packets to be pushed, /app1/ul/data from application URL “https://app.orbiwise.com/app1/ul/data”\nThe Host Username &amp; Host Password must be entered if the application contains credentials. Assign Application to the Specific Devices: Applications accounts only give access to (and send push notification for) devices that has been assigned to it. Devices are assigned to an application by following ways, Go to Manage Devices -&gt; select the devices -&gt; click on”Action” -&gt; select App Assignment from dropdown list,  On clicking App Assignment option will brings up the Manage Apps window, then select App ID (Application) -&gt; then click on Add button,  Push notification is disabled by default but can be enabled and disabled from the option Start Push/Stop Push available in Action dropdown list on the right of each application account as describe in below picture,  The OrbiWAN will start pushing the payload to the application once the “Start Push” mode has enabled and in this case OrbiWAN will not store payloads anymore in database that are pushed to application successfully. Global Push Configuration: A default application can be assignedto all the devices in a current user profile though creating/setting up a ** Global Push Configuration “This is done from the” Applications page using Edit Default Push Config”option.  After setting up Global Push Configuration, user has to enabled “Start Default Push” mode to push payloads to the application and in this case OrbiWAN will not store payloads anymore in database that are pushed to application successfully.","url":"application-management.html","anchor":"creating-application-from-ui"},{"objectID":"application-management-httphttps-push-mode","hierarchy_lvl0":"Documentation","hierarchy_lvl1":"Application Management","hierarchy_lvl2":"HTTP/HTTPS Push Mode","content":" HTTP/HTTPS Push Mode When an application wants to receive push message from the OrbiWAN server it must first implement a HTTPS host interface that can be reached from the OrbiWAN and identified by a hostname or IP address. The application can then register the interface on the OrbiWAN and start push mode, which will cause the OrbiWAN to push any new payload or update in status directly to the application host interface.  Procedure to Push packets to the Application Server via HTTP/HTTPs: Register the device Join the device in the network Add an application from the Dassui Assign an application to device Enable \"Start Push\" mode for the application on DASSUI The OrbiWAN server will then start pushing the payloads to the application endpoint and if it reached successfully on application endpoint, OrbiWAN will not store payloads in the database anymore. The application must implement the paths specified in previous sections for each of the different types of push messages. There are following types of push notification messages that are sent, application can decide to subscribe to only a subset of them, payloads_ul payloads_ul_early payloads_dl multicast status location nodeinfo join joininfo Eash of the above push notification message types are described in the following table, \n\t\n\t\t\n\t\t\t\n\t\t\tNotification\n\t\t\t\n\t\t\t\n\t\t\tDescription\n\t\t\t\n\t\t\n\t\t\n\t\t\t\n\t\t\tpayloads_ul_early\n\t\t\t\n\t\t\t\n\t\t\tUplink message received. The message body contains the uplink message data and port number. This notification is sent as early as possible to allow the application to be able to respond to the message and have it send back to the device on the immediate following downlink opportunity.\n\t\t\t\n\t\t\n\t\t\n\t\t\t\n\t\t\tpayloads_ul (complete)\n\t\t\t\n\t\t\t\n\t\t\tUplink message received. The message body contains the uplink message data and port number, and the RSSI and SNR of the best gateway that received the data. Further depending on the rights of the application, the message may also contain the full list of gateways that received the message and the estimated Geo location of the device. As this message requires aggregation of data from multiple gateways and optional processing of geo locations data, this message will arrive too late to be able to send data back to the device on the immediately following downlink opportunity.\n\t\t\t\n\t\t\n\t\t\n\t\t\t\n\t\t\tpayloads_dl\n\t\t\t\n\t\t\t\n\t\t\tThis notification is send with the status of a scheduled downlink. The notification will be send when the downlink have actually been sent, and in case of confirmed downlink, when the downlink have been (or not) acknowledged. If an error happened on the downlink this will also be indicated on this notification. This notification may be send several times as the state changes.\n\t\t\t\n\t\t\n\t\t\n\t\t\t\n\t\t\tmulticast\n\t\t\t\n\t\t\t\n\t\t\tThe multicast status is similar to the payloads_dl message, but is for multicast messages.\n\t\t\t\n\t\t\n\t\t\n\t\t\t\n\t\t\tnodeinfo\n\t\t\t\n\t\t\t\n\t\t\tA nodeinfo notification is sent tell the application that the state of a device has changed. This is the case when the network schedules a downlink without request from the application. In this case the downlink FCNT counter is incremented, and the nodeinfo notification is send to notify the application of this change.\n\t\t\t\n\t\t\n\t\t\n\t\t\t\n\t\t\tstatus\n\t\t\t\n\t\t\t\n\t\t\tThe status notification is sent when the device have reported back the DevStatusAns which report the battery level of the device and the downlink link margin.\n\t\t\t\n\t\t\n\t\t\n\t\t\t\n\t\t\tjoin\n\t\t\t\n\t\t\t\n\t\t\tRaw LoraWAN join message sent to the application when the application want to manage directly the JOIN procedure and process the JOIN-REQ, JOIN-ACCEPT and session keys.\n\t\t\t\n\t\t\n\t\t\n\t\t\t\n\t\t\tjoininfo\n\t\t\t\n\t\t\t\n\t\t\tSend when the a device have send a join request message and the network has accepted the device.\n\t\t\t\n\t\t\n\t\t\n\t\t\t\n\t\t\tlocation\n\t\t\t\n\t\t\t\n\t\t\tA location estimate has been updated for the device. Note, this message is redundant with the payloads_ul(complete) notification that will also include the location information when available.\n\t\t\t\n\t\t\n\t\n You can also follow the video to see it in action. Application Management \n    \n    Your browser does not support HTML video.\n","url":"application-management.html","anchor":"httphttps-push-mode"},{"objectID":"application-management-mqtt-push-mode","hierarchy_lvl0":"Documentation","hierarchy_lvl1":"Application Management","hierarchy_lvl2":"MQTT Push Mode","content":" MQTT Push Mode An application can connect to the OrbiWAN using the MQTT(s) protocol. To connect, the application must provide the username and password from the owning account. URL:   mqtts://dass-host[:port]  \nCredentials mandatory: account username/password Once connected the application must subscribe to channels to receive the push information. The available channels are: \n  username/payloads_ul\n  username/payloads_dl\n  username/nodeinfo\n  username/status\n  username/join  (* not currently available)\n  username/joininfo\n  username/location\n Once a subscription has been made the OrbiWAN will send message to the application using the above listed channels. The payloads are in the same JSON format as their REST push versions. The REST message is encapsulated in an outer object with the name of the message type. I.e Channel JSON Message \n\t\n\t\t\n\t\t\tMQTT topic\n\t\t\t\n\t\t\t\n\t\t\tJSON body\n\t\t\t\n\t\t\n\t\t\n\t\t\t\n\t\t\tusername/payloads_ul\n\t\t\t\n\t\t\t\n\t\t\t{ \"payloads_ul\": {...} }\n\t\t\t\n\t\t\n\t\t\n\t\t\t\n\t\t\tusername/payloads_dl\n\t\t\t\n\t\t\t\n\t\t\t{ \"payloads_dl\": {...} }\n\t\t\t\n\t\t\n\t\t\n\t\t\t\n\t\t\tusername/multicast\n\t\t\t\n\t\t\t\n\t\t\t{ \"multicast\": {...} }\n\t\t\t\n\t\t\n\t\t\n\t\t\t\n\t\t\tusername/nodeinfo\n\t\t\t\n\t\t\t\n\t\t\t{ \"nodeinfo\": {...} }\n\t\t\t\n\t\t\n\t\t\n\t\t\t\n\t\t\tusername/status\n\t\t\t\n\t\t\t\n\t\t\t{ \"status\": {...} }\n\t\t\t\n\t\t\n\t\t\n\t\t\t\n\t\t\tusername/join\n\t\t\t\n\t\t\t\n\t\t\t{ \"join\": {...} }\n\t\t\t\n\t\t\n\t\t\n\t\t\t\n\t\t\tusername/joininfo\n\t\t\t\n\t\t\t\n\t\t\t{ \"joininfo\": {...} }\n\t\t\t\n\t\t\n\t\t\n\t\t\t\n\t\t\tusername/location\n\t\t\t\n\t\t\t\n\t\t\t{ \"location\": {...} }\n\t\t\t\n\t\t\n\t\n Procedure to Push packets via MQTT protocol from DASS: An application can connect to the OrbiWAN using the MQTT(s) protocol.  Basically the Network server will send packets to OrbiWAN server that can be seen in the UI. If user has subscribed on the payload topic via MQTT, then OrbiWAN server will send packets to MQTT.  We have one ** sample application ** build in ** node.js ** to run push tests via MQTT to application server, Pre-requisites: \n  Install node.js in the system from https://nodejs.org/en\n  Copy ubiq-mqtt-client.js files in a directory, e.g Desktop/MQTT_Push\n  Update file with OrbiWAN URL and credentials for the test,\n <code class=\"language-js\">// ubiq-mqtt-client.js:\n\nvar conf = {\n\n    host: \"dass.url\",\n    port: null,\n    userid: \"yyy\",\n    password: \"zzz\"\n\n};\n</code> \n  Go to the directory where the file is copied and modified =&gt; e.g. cd Desktop/MQTT_Push\n  Execute the following command, this will install the missing packages\n  npm install MQTT\n  Then run node ubiq-mqtt-client.js, it should show that it connect to the OrbiWAN\n  Any new packet received by a device from the same OrbiWAN user account shall be pushed and thus displayed in window.\n Following is the response of MQTT client: <code class=\"language-json\">    {\n            \"payloads_dl\": {\n            \"confirmed\": true,                      // optional, defaults to true\n            \"deveui\": \"aabbccdd00000000\",\n            \"data\": \"aabbcc\",\n            \"port\": 10,\n            \"data_format\": \"base64\" | \"hex\",        // optional, default to base64\n            \"fcnt\": 12,                             // optional\n            \"mode\": \"fail_on_busy\",                 // optional, default to enqueue_on_busy\n            \"session_id\": \"uuid-of-session\",        // optional,\n            \"tag\": \"request-tag\"                    // optional\n        }\n    }\n\n</code> Upon reception of the downlink message, provided there are no errors, the OrbiWAN immediately send back the following message: Topic: username/payloads_dl <code class=\"language-json\">{\n         \"payloads_dl\": {\n            \"deveui\": \"hex\",            // DevEUI of the receiving device\n            \"id\": 252,                  // unique ID of the dl payload\n            \"fcnt\": 10,                 // the used downlink FCNT\n            \"port\": 1,                  // the used port\n            \"transmissionStatus\": 0,    // see table in section 4.4.5\n            \"session_id\": \"UUID\",       // session ID when packet was created\n            \"tag\": \"request-tag\"\n        }\n    }\n</code> The transmissionStatus is set to zero indicating that the payload have been enqueued. Note this message is only send back on MQTT and not pushed in general (i.e. applications listening for REST or Web-Socket will not receive this message). In the even of an error, the following error object is sent: Topic: username/payloads_dl <code class=\"language-json\">  {\n        \"error\": {\n            \"tag\": \"request-tag\",           // reference to requesting message\n            \"error_msg\": \"error message\",\n            \"status_code\": 404              // REST style status code, e.g. 404 not found\n        }\n  }\n</code> Multicast via MQTT: Multicast message can be send via MQTT by sending the following message: Topic: username/send_multicast <code class=\"language-json\">   {\n        \"multicast\": {\n            \"groupid\": \"group-id\",\n            \"data\": \"aabbcc\",\n            \"port\": 10,\n            \"data_format\": \"base64\" | \"hex\",        // optional, default to base64\n            \"fcnt\": 12,                             // optional\n            \"mode\": \"fail_on_busy\",                 // optional, default to enqueue_on_busy\n            \"tag\": \"free-text-tag\"                  // optional\n        }\n    }\n</code> Topic: username/multicast <code class=\"language-json\">    {\n        \"multicast\": {\n            \"groupid\": \"group-id\",      // multicast group id\n            \"id\": 252,                  // unique ID of the dl payload\n            \"fcnt\": 10,                 // the used downlink FCNT\n            \"port\": 1,                  // the used port\n            \"transmissionStatus\": 0,    // see table in section 4.4.5\n            \"session_id\": \"UUID\",       // session ID when packet was created\n            \"tag\": \"request-tag\"\n        }\n    }\n</code> The transmissionStatus is set to zero indicating that the payload have been enqueued. Note this message is only send back on MQTT and not pushed in general (i.e. applications listening for REST or Web-Socket will not receive this message). In the even of an error, the following error object is sent: Topic: username/multicast <code class=\"language-json\">   {\n        \"error\": {\n            \"tag\": \"request-tag\",           // reference to requesting message\n            \"error_msg\": \"error message\",\n            \"status_code\": 404              // REST style status code, e.g. 404 not found\n        }\n    }\n</code>","url":"application-management.html","anchor":"mqtt-push-mode"},{"objectID":"aws-iot-core-integration-testing-aws-iot-core-integration","hierarchy_lvl0":"Documentation","hierarchy_lvl1":"AWS Iot Core Integration","hierarchy_lvl2":"Testing AWS IoT Core integration","content":" Testing AWS IoT Core integration The HTTPS connector publishes event-based messages to the pre-determined topics when specific device events occur and allows applications to send commands back to the devices, for example, to update properties or invoke actions. The available topics are: \n    \n        MQTT topic\n        Description\n    \n    \n        orbiwan/lorawan/{deveui}/uplink_early\n        Uplink message received. The message body contains the uplink message data and port number. This notification is sent as early as possible to allow the application to be able to respond to the message and have it send back to the device on the immediate following downlink opportunity.\n    \n    \n        orbiwan/lorawan/{deveui}/uplink\n        Uplink message received. The message body contains the uplink message data and port number, and the RSSI and SNR of the best gateway that received the data. Further depending on the rights of the application, the message may also contain the full list of gateways that received the message and the estimated Geo location of the device. As this message requires aggregation of data from multiple gateways and optional processing of geo locations data, this message will arrive too late to be able to send data back to the device on the immediately following downlink opportunity.\n    \n    \n        orbiwan/lorawan/{deveui}/downlink/status\n        This notification is send with the status of a scheduled downlink. The notification will be send when the downlink have actually been sent, and in case of confirmed downlink, when the downlink have been (or not) acknowledged. If an error happened on the downlink this will also be indicated on this notification. This notification may be send several times as the state changes.\n    \n    \n        orbiwan/lorawan/{deveui}/joininfo\n        Send when the a device has send a join request message and the network has accepted the device.\n    \n    \n        orbiwan/lorawan/{deveui}/nodeinfo\n        A nodeinfo notification is sent to tell the application that the state of a device has changed. This is the case when the network schedules a downlink without request from the application. In this case the downlink FCNT counter is incremented, and the nodeinfo notification is send to notify the application of this change.\n    \n    \n        orbiwan/lorawan/{deveui}/location\n        A location estimate has been updated for the device. Note, this message is redundant with the orbiwan/lorawan/{deveui}/uplink notification that will also include the location information when available.\n    \n    \n        orbiwan/lorawan/{deveui}/status\n        The status notification is sent when the device have reported back the DevStatusAns which report the battery level of the device and the downlink link margin.\n    \n    \n        orbiwan/lorawan/appchange\n        The appchange notification is sent every time a device subscribes or unsubscribes to the AWS IoT Core application sub-account.\n    \n Downlink messages must be send to the following topic: orbiwan/lorawan/{deveui}/downlink. The following sections describe how to test uplink and downlink message flows. Uplink payloads You can use the IoT Core MQTT test client to monitor the MQTT messages being passed in your AWS account: \n  Navigate to the IoT Core console,  choose Test on the navigation pane, and select Subscribe to a topic\n  Configure the MQTT client to subscribe to the desired topics. For example, to subscribe to uplink payloads, enter orbiwan/lorawan/+/uplink, set the QoS level and click Subscribe\n  \n  Verify the published data in the IoT Core MQTT Test Client\n  Send a downlink payload to a device Applications can send dowlink payloads to LoRaWAN devices by publishing an MQTT message to AWS IoT Core. Hexadecimal payloads published to the topic orbiwan/lorawan/{deveui}/downlink are sent to a Lambda function that republishes the messages by making POST requests to the appropriate OrbiWAN server for it to transmit them to the devices on next opportunity. Note that the DevEUI of the target device will be taken from the MQTT topic. The message is a JSON object with the following format: <code class=\"language-json\">{\n    \"data\": \"aabbcc\",  // Hex payload\n    \"port\": 20         // LoRaWAN port\n}\n</code> The picture below illustrates the overall approach:  You can use the IoT Core MQTT test client to publish downlink messages to OrbiWAN: \n  Go to the IoT Core console,  choose Test on the navigation pane, and subscribe to topic orbiwan/lorawan/+/downlink/status to see a response from OrbiWAN once a downlink message transaction has completed:\n  \n  Select Publish to a topic\n  Enter the downlink topic, set the QoS, define the message payload and click “Publish”\n  \n  Monitor the response from the OrbiWise LNS that contains the status of the scheduled downlink message:\n  Note that this notification will be sent several times as the state changes. The meaning of the transmission status is the following: \n    \n        Transmission status\n        Description\n    \n    \n        0\n        Payload pending transmission (i.e. not sent yet).\n    \n    \n        1\n        Payload has been sent, but reception status unknown.\n    \n    \n        2\n        Payload has been sent and acknowledged by the device.\n    \n    \n        3\n        Payload has been sent, and NOT acknowledged by the device =&gt; most likely the device did not receive the downlink payload.\n    \n    \n        4\n        An error has been discovered on the payload. The possible reasons for this error are: FCNT collision, payload size too big.\n    \n    \n        5\n        Payload has been cancelled. This happens if downlinks have been queued but are erased again due to new JOIN, or if the payloads have been purged.\n    \n If an error happened on the downlink this will be indicated on this notification:  Downlink payloads will be listed in the OrbiWAN GUI, provided they have been successfully scheduled:  Note that applications can also publish their messsages by making POST requests to the following URL: <code class=\"language-shell\">https://AWS_IoT_data_endpoint/topics/orbiwan/lorawan/{deveui}/downlink?qos=1\n</code> To find your IoT data custom endpoint, got to the AWS IoT Core console and choose Settings. See the snippet below for an example of how to send a downlink payload through HTTPS connection to AWS IoT Core. <code class=\"language-python\">import requests\nimport argparse\n\n# Define command-line parameters\nparser = argparse.ArgumentParser(description='Send message through HTTP POST')\nparser.add_argument('--endpoint', required=True,\n                    help='AWS IoT data custom endpoint, not including a port.')\nparser.add_argument('--cert', required=True,\n                    help='Path to cert file, in PEM format.')\nparser.add_argument('--key', required=True,\n                    help='Path to private key, in PEM format.')\nparser.add_argument('--deveui', required=True,\n                    help='DevEUI of the target device.')\nparser.add_argument('--message', default='{\"data\":\"aabbcc\",\"port\":10}',\n                    help='Message to publish.')\n\n# Parse command-line parameter values\nargs = parser.parse_args()\n\n# Define values for HTTPS request\ntopic = 'orbiwan/lorawan/%s/downlink' % args.deveui\npublish_url = 'https://%s:8443/topics/%s?qos=1' % (args.endpoint, topic)\npublish_msg = args.message.encode('utf-8')\n\n# Make HTTP POST request\npublish = requests.request('POST',\n                           publish_url,\n                           data=publish_msg,\n                           cert=[args.cert, args.key])\n\n# Print response\nprint('Response status: ', str(publish.status_code))\nif publish.status_code == 200:\n    print('Response body:', publish.text)\n</code>","url":"aws-iot-core-integration.html","anchor":"testing-aws-iot-core-integration"},{"objectID":"device-management-register-device","hierarchy_lvl0":"Documentation","hierarchy_lvl1":"Device Management","hierarchy_lvl2":"Register Device","content":" Register Device Registering a new device on UI in release 6.0 has 2 ways, either the devices is being registered using  device-profile  (and  service-profile ) or the device is being registered using the direct registration (legacy  method of registration prior to release 6). \n  Once you login\n  Go to Devices\n  Click on Manage devices.\n  There will be option to  Add device.\n  Add device with profile. OrbiWan from release 6 uses profiles to manage the increasingly complex set of parameters that are needed to manage devices. Two kind of profiles are assigned to each device. A  device profile  and a  service profile . Below are the steps to add device with profile On clicking the Add Device with profile button brings up the following pop-up window:  When using profiles, the number of fields needed to register a device is far less than when doing direct registration. The  device profile  described the device parameters such as the version LoRaWAN MAC, device capabilities, supported regions, etc. The information needed to create a device profile must typically be provided by the device manufacturer. Device profiles can be created by the network operator but can also be created by the customers/users. Devices of same kind normally use the same device profile. The  service profile  defines the way the network will manage the device. This includes the QoS, allowed traffic volume, etc. This profile is always created by the network operator and is assigned to customers. Customers may derive their own restricted versions with less or equal allowed services. When a customer/user register a new device a  device profile  and  service profile  must be selected and provided in the registration message Profiles can be created as links and referenced from other accounts. For example a customer may create a device profile at the root level of the customer account, and then share this profile as links to some of its users. As it is a link, if the root profile is changed, the change will automatically apply to all the linked usages of the profile","url":"devices-management.html","anchor":"register-device"},{"objectID":"device-management-create-device-profile","hierarchy_lvl0":"Documentation","hierarchy_lvl1":"Device Management","hierarchy_lvl2":"Create Device Profile","content":" Create Device Profile We can create Device Profiles:- \n  Profiles\n  Device Profiles\n  Add Device Profile\n  Specify the required parameters\n  Add Profile\n  We have to mention whether the device is OTAA or ABP in the device activation mode field. The LoRaWAN MAC version needs to be selected from a pre-defined list of allowed values.   You can also follow the video to see it in action. Device Join via ABP Activation \n    \n    Your browser does not support HTML video.\n Device Join via OTAA Activation \n    \n    Your browser does not support HTML video.\n List Device Profiles We can see the list of device profiles in UI. The list of device profiles can be seen from the following steps: \n  Login to UI\n  Profiles\n  Device Profiles\n  Modify Device Profiles We can also edit the device profile from UI. The device profiles can be edited from the following steps: \n  Login to UI\n  Device Profile\n  Action (individual profile)\n  Edit Profile -Update the required Values\n  Update Profile\n Note :- The screens for the Create Device Profile and Edit Device Profile are same. Delete Device Profiles We can delete the device profile from UI. The device profiles can be deleted from the following steps: \n  Login to UI\n  Profiles\n  Device Profile\n  Action(individual profile)\n  Delete Profile\n","url":"devices-management.html","anchor":"create-device-profile"},{"objectID":"device-management-edit-device-parameters","hierarchy_lvl0":"Documentation","hierarchy_lvl1":"Device Management","hierarchy_lvl2":"Edit Device Parameters","content":" Edit Device Parameters Once a device has been added (registered), the device parameters can still be changed. This can be done by following 2 methods, Edit device from UI \n  Select Edit Device.. option from dropdown in the device list as described in below figure,\n  \n  This will open the same window as for the “Add Device” (or “Add device without Profile” depending on the mode of registration) but with the values filled-in and in “read- only” mode except for the Comment field. A padlock symbol at the bottom left of the page indicates that the values are locked (read-only). See picture below for profile based device:\n  \n  And the picture below show the same for a device that was registered without Profile.\n  \n  \n    To modify any value (other than the comment field), click on the padlock symbol to unlock the values. Once the device has been unlocked the values can be changed. Values that have been changed will be highlighted with a green frame.\n  \n  \n    Invalid input values are marked with a red frame and it will not be possible to accept the changes and update the device until all changed settings are valid (and in green) or reset to the unchanged state.\n  \n  \n    Once the changes are complete press “Update Device” to apply the changes.\n  \n  \n    A new window will pop up to confirm that the change has been applied.\n  \n You can also follow the video to see it in action. Devices Activity \n    \n    Your browser does not support HTML video.\n","url":"devices-management.html","anchor":"edit-device-parameters"},{"objectID":"device-management-batch-registration","hierarchy_lvl0":"Documentation","hierarchy_lvl1":"Device Management","hierarchy_lvl2":"Batch Registration","content":" Batch Registration When many devices must be registered, it is not practical to manually add each device individually via the Add Device UI. To register many devices in one operation, the UI provides a batch registration feature. Select Batch registration from the Devices dropdown menu to go to the batch registration view.  The batch registration view has a file drop zone at the top where a CSV can be dragged and dropped. It is also possible to click on the drop zone to open a file explorer to select the file. The batch registration view with the file drop zone is shown below.  Once a file has been selected or dropped on the drop zone, the file is uploaded and analysed and a list with devices and their status is shown. See figure below.  The table show the status of each DevEUI provided in the file. The possible states are: \n  \n    \n      Status\n      Descripation\n    \n  \n  \n    \n      Device not found\n      the device is currently unknown on the network [the normal state].\n    \n    \n      Registered\n      the device is already registered on the network.\n    \n  \n Check boxes at the beginning of each line can be used to unselect devices that should be processed by the batch processing. Press Register to start the registration process to add the checked devices to the network. The progress bar above the buttons will show the status of the registration. Devices can also be deleted using the batch processing by pressing Delete to delete all the checked devices in the list. Once the batch process has been started, if there are many devices to process, the process can take a while to complete. It is safe to leave the page and even sign out of the UI. The batch process continues to run until it is completed. It is always possible to sign in again check the status by going back to the batch registration view. The process can be aborted by pressing the clear button. Any devices that have already been registered remain registered. You can also follow the video to see it in action. Batch Registartion \n    \n    Your browser does not support HTML video.\n","url":"devices-management.html","anchor":"batch-registration"},{"objectID":"device-management-payload-decoder","hierarchy_lvl0":"Documentation","hierarchy_lvl1":"Device Management","hierarchy_lvl2":"Payload Decoder","content":" Payload Decoder Payload decoder is a special feature of OrbiWAN which allow decoding(as per configured decoding function by the user) of payload before sending it to end application. Also, help of payload decoder you can integrate Thingsboard with OrbiWAN. Prerequisite: The decode function is only called for devices that can be decrypted by the network, meaning the network must be able to access the AppSKey. How it works: The OrbiWAN has support for inserting small Javascript functions to perform encoding of messages to customizable formats as well as decoder functions to decode the binary payload from a device and translate it into device agnostic data. The functions are provided in Javascript and the OrbiWAN will execute them when needed. As the functions are executed in real-time the OrbiWAN put some restrictions on what is allowed and in general, the Javascript function must be short and fast to execute. The OrbiWAN will accumulate the time spent in a function and if the average time over a period exceeds 0.1ms the function will be automatically disabled. The functions are executed in a sandbox which means the use of library function inside the function is highly restricted. The functions are associated to the devices with device registration parameter* payload_decoder_js *. When a function is defined, the uplink messages pushed to the applications contain the object that is returned by the function. It is also possible to make the application push only the decoded object parameters. This can be done by changing the data_format of the application with decoded_json. And finally, this is also possible to customize the application URL with device tags so the OrbiWAN will customize the URL to which it pushed for each device. This is often used to connect directly to a dashboard. Payload Decoding function A payload decoding function is used to translate the binary format of a device into a more device agnostic format. E.g. for a temperature sensor, the sensor may send the temperature readings in a binary format that will have to be converted into an actual message field called “temperature” with and value directly in degree centigrade (or any other unit). When a payload have been decoding in this way it is typically possible to forward the data directly to end applications that may not know the exact sensor used (and hence would not understand the binary payload format), but understand the generic “temperature” field and is able to process it. Note, the decode function is only called for devices that can be decrypted by the network, meaning the network must be able to access the AppSKey. To help expose the data to varies IoT platforms and frameworks, it is useful (and highly recommended) to provide also a model description of the output from the device. A model describes which parameters are available from the payload decoder. The model can be queried through REST API on the OrbiWAN so that applications can ask device which kind of data is provided by the device. E.g. if the device is a temperature sensor it will typically provide the temperature. In this case, the model would contain a parameter “temperature” of type “number” with an optional description. A payload decoding function can be assigned to a device function. <code class=\"language-java\">model = {\ntemperature:\"number\",\ncolor:\"string\",\nopen:\"boolean\"\n}\n\ndecoder = function(uplink, meta) {\nconst temp =(uplink.data[0] +uplink.data[1] *256) / 10;\nconst color = temp &gt; 30 ? \"red\": \"green\";\nconst open = uplink.data[2] == 1 ? true: false;\nconst output = {\n\njson:{\ntemperature: temp,\ncolor: color,\nopen: open\n}}\nreturn output;\n}\n</code> The decoder function is called for each payload to decode. The function is called with the following arguments: <code class=\"language-js\">uplink:{\ndata: Buffer,// Buffer object from NodeJS\nfport: 1, // the port number\ndevaddr: 123,// the DevAddr of the device\nfcnt: 2345 // the FCNT of the uplink\n\n}\n</code> The meta parameter has these fields: <code class=\"language-js\">meta:{\n\nfreq: 868.1, // received frequency\nrssi: -102, // RSSI from best received gateway\nsnr: 10, // SNR from best received gateway\ntags: { // optional tags object on each device\n\n\"user-tag-1\":\"value\" //\n}\n}\n</code> Note: the object may have more fields - but presently the above fields are the only fields guaranteed to be there. The easiest way to set the decoder function is to use e.g. postman and use the direct set key option. This allows to write put the decoder function directly as raw text to the OrbiWAN (without having to format it into JSON): PUT /rest/nodes/{deveui}?key=payload_decoder_js BODY:  raw text of the function described above Alternatively, it can be set as JSON: PUT /rest/nodes/{deveui}\nBODY: {“payload_decoder_js:”JSON-escaped-string-with-above-code”} Devices tags: Tags are used to customize the URL to which the OrbiWAN will push, which is required for most of the application platforms. Tags can be added freely to any device. PUT /rest/nodes/{deveui}\nBODY: <code class=\"language-json\">{\n\"tags\": {\n\"tb-access-token\": \"23req34erg45rg\",\n\"tb-device-id\": \"e450bd92-69f1-491d-b367-390ad1133148\"\n}\n}\n</code> The naming of the tags can be chosen freely. Assign the access token values (and optionally the device ID) from the TB(ThingsBoard) platform for each of the devices. Assigning these tags will allow the OrbiWAN to access the values for each device when the push message is getting sent. Finally, we need to make the URL use the tags. When using the “decoded_json” mode, the OrbiWAN will not append any path to the push prefix path. The prefix path will essentially be the complete path used for the push. We can now use parameter substitution in the path to making the OrbiWAN insert the correct path. Parameters to be substituted in the path are specified this way, e.g.: /path/%{parameter}/end?find=false, where parameters can be e.g. deveui and other parameters. Now we can use this to build the start message for an application account associated with the devices that must send data to TB(ThingsBoard). PUT /rest/pushmode/start/{name-of-app-account}\nBODY: <code class=\"language-json\">{\n\n\"data_format\": \"decoded_json\",\n\"host\": \"https://demo.thingsboard.io\",\n\"path_prefix\": \"/REST API/v1/${devtags.tb-access-token}/telemetry\",\n\"port\": 443,\n\"retry_policy\": 0\n\n}\n</code> Note that pushmode/start works with the name of the application but not with its uuid. Uuid is used for authentication. When the above command is issued, the application account will start to push the decoded payload values to the demo.thingsboard.io/REST API/vi/xyz/telemetry URL, where xyz will be automatically replaced with the value of the device tag with the name “tb-access-token”. You can also follow the video to see it in action. Paylaod Decoder \n    \n    Your browser does not support HTML video.\n","url":"devices-management.html","anchor":"payload-decoder"},{"objectID":"device-management-payload-management-using-ui","hierarchy_lvl0":"Documentation","hierarchy_lvl1":"Device Management","hierarchy_lvl2":"Payload Management Using UI","content":" Payload Management Using UI To see data from a device, Login into UI -&gt; go to Devices -&gt; Click on Manage devices tab. Select the device to view the data from device list-&gt; Click on Action -&gt; View Data.  The list will bepopulated for both Uplink &amp; Downlink packets. Each packet is shown with a timestamp, FCNT, Port, Status, Data Rate, RSSI etc. See picture below.  The Dass user/customer cansee the payload for any device by clicking on Show Message Payload button on Device Activity Page.This is only available for user/customer that have rights enabled for Message Payload on user account settings to see decoded payload message. See picture below.  ","url":"devices-management.html","anchor":"payload-management-using-ui"},{"objectID":"device-management-create-groups-for-multicasting","hierarchy_lvl0":"Documentation","hierarchy_lvl1":"Device Management","hierarchy_lvl2":"Create Groups (For Multicasting)","content":" Create Groups (For Multicasting) Devices can be grouped by using the group feature. To create a group, click on “Groups” menu. This open the following dialog:We can create groups using UI:- \n  Login to UI\n  Groups -&gt; Add Group\n  Fill the details\n  Save\n  Enter a valid group ID and the title of the group. The title is a plain text description of the groups and can contain spaces, whereas the group ID is must not contain any spaces. The comment is an optional field that can be used by the user to provide additional information about the group. In the multicast section the three LoRaWAN multicast values for Class C devices can be entered. These are: \n  Multicast DevADDR\n  Multicast NwkSKey\n  Multicast AppSKey\n These values must match the devices of all the devices. Currently LoRaWAN does not specify how the devices gets provisioned with the multicast parameters, hence it is up to the user or the users application to ensure that the multicast parameters are correct. DevAddr should be unique per group. The Devaddr is used to locate the multicast packet in trace. By default, the Ping-slot Periodicity is set to Class C. In case of class B we can set this to Class B multicast.","url":"devices-management.html","anchor":"create-groups-for-multicasting"},{"objectID":"device-management-multicast-dl-scheduling","hierarchy_lvl0":"Documentation","hierarchy_lvl1":"Device Management","hierarchy_lvl2":"Multicast DL Scheduling","content":" Multicast DL Scheduling Multicast is used to send DL to multiple devices which belongs to a group, it is only applicable to class B and C devices.\nThere are two ways to send Multicast Downlink: Schedule a Multicast DL: After creating a group and assigning it to the respective devices user can send Multicast data to all the devices associated with that group. To send a multicast using UI, \n  Login into UI\n  Go to Groups tab\n  Click on Action button,\n  \n  Then pressing the Send Multicast button will brings up the following “Send Data window for user to enter the details for Multicast,\n  User needs to enter, the Payload to be send to devices, Port and FCNT (if required, make sure it is not duplicated),\n  Finally, Click on the Send button then all the devices assigned to this group will receive the DL packet from this group devaddr,\n  You can also follow the video to see it in action. Group Management and Multicast \n    \n    Your browser does not support HTML video.\n","url":"devices-management.html","anchor":"multicast-dl-scheduling"},{"objectID":"environment-scalability-overview","hierarchy_lvl0":"Documentation","hierarchy_lvl1":"Environment Scalability","hierarchy_lvl2":"Overview","content":" Overview This article discusses performance and reliability best practices for OrbiWAN deployed to production.","url":"env-scalability.html","anchor":"overview"},{"objectID":"gateway-management-add-gateway","hierarchy_lvl0":"Documentation","hierarchy_lvl1":"Gateway Management","hierarchy_lvl2":"Add Gateway","content":" Add Gateway One of the important steps you are supposed to do after login is to latch/register your gateway on OrbiWAN Network. To register the gateways you can follow these simple steps - \n  Navigate to Gateways menu –&gt; Add Gateways.\n  Enter the Gateway name and Select the model.\n  Copy the command provide in Installation box to provision the gateway.\n  Login to the gateway using SSH and paste the copied command in the gateway shell.\n  This command will download the Gateway Software and install on the Gateway.\n  Once the Software is installed, Reboot the gateway.\n  You can also follow the video to see it in action. \n    \n    Your browser does not support HTML video.\n","url":"gateway-management.html","anchor":"add-gateway"},{"objectID":"rest-api-purpose","hierarchy_lvl0":"Documentation","hierarchy_lvl1":"REST API","hierarchy_lvl2":"Purpose","content":" Purpose This document specifies the interface between the Data Access Sub-System and external applications.","url":"rest.html","anchor":"purpose"},{"objectID":"rest-api-status-of-document","hierarchy_lvl0":"Documentation","hierarchy_lvl1":"REST API","hierarchy_lvl2":"Status of document","content":" Status of document This version 2.0 of the DASS interface specification is covering OrbiWAN release 6.0. Please note that for all returned message JSON objects there may be additional fields to those documented in this document. An application should never rely on any field not documented in this document as these additional fields may change or disappear without prior warning from one release to the next.","url":"rest.html","anchor":"status-of-document"},{"objectID":"rest-api-scope","hierarchy_lvl0":"Documentation","hierarchy_lvl1":"REST API","hierarchy_lvl2":"Scope","content":" Scope","url":"rest.html","anchor":"scope"},{"objectID":"rest-api-reference","hierarchy_lvl0":"Documentation","hierarchy_lvl1":"REST API","hierarchy_lvl2":"Reference","content":" Reference [1]\tLoRaWAN™ V1.0 \n[2]\tLoRaWAN™ Backend Interfaces Specification, V1.0 \n[3]\tGuidelines for 64-bit Global Identifier (EUI-64) General \n\thttps://standards.ieee.org/develop/regauth/tut/eui64.pdf \n[4]\tBase64 encoding,  https://tools.ietf.org/html/rfc4648 \\","url":"rest.html","anchor":"reference"},{"objectID":"rest-api-definitions-acronyms-and-abbreviations","hierarchy_lvl0":"Documentation","hierarchy_lvl1":"REST API","hierarchy_lvl2":"Definitions, Acronyms, and Abbreviations","content":" Definitions, Acronyms, and Abbreviations DASS\tData Access Sub-System \nRNSS\tRadio Network Sub-System \nAPP     Application \nCRUD\tCreate, Read, Update &amp; Delete. REST protocol paradigm \nFCNT\tUp – or downlink LoRaWAN frame counter as defined in [1]  \nJSON\tJavaScript Object Notation. Lightweight data-interchange format \nBase64  Encoding scheme is defined in [4]. \\ Interface overview This document details the interface seen by the customer applications towards the OrbiWise Data Access Sub System (DASS). The interface enables the customer to manage devices on the network as well as the operator to register customers. Data send to and received from the devices are cached in persistent temporary storage inside the RNSS ensuring that there are no real-time constraints on the applications to access the data. Figure @fig:interfaceOverview show the context of the interface in the overall network. {#fig:interfaceOverview} Messages are REST based following the “CRUD” principle with transport over HTTPS. Authentication is done using a bearer token (as per OAuth2 standard) or via the Basic authentication scheme of HTTP(S). Note: basic authentication may be disabled and only token authentication is allowed. Basic authentication uses the standard header field “Authorization” with the argument string: “Basic [username:password]base64 encoded”. For OAuth2 a token must first be requested using the OAuth2 API (see @sec:oauth2).\nData exchanged in the message body is JSON format and will have “Content-Type” HTTP header directives with “application/json”. All messages are HTTP v1.1 compliant. {#fig:stackOverview} The Application&lt;-&gt;DASS interface is a host/client &lt;-&gt; host/client interface, meaning that both sides can initiate requests and receive requests. After initial start-up, the DASS will act as host only and the applications will connect to the DASS as clients only. In this “pull-mode” each application must initiate all communication and must poll (GET) the DASS for updates. To avoid this polling an application must register its own host interface on the DASS after which the DASS will be able to act as a client too and make unsolicited PUT/POST to the application with incoming payload and update of status. This is “push-mode”. Push-mode and Pull-mode co-exist simultaneously, but once push-mode is started, only house-keeping operations will be performed in pull-mode and all “normal” data flow is performed in push-mode for the application that registered its host interface. Message Exchange Description Several classes of API commands are available, the most important being; device management, device payloads commands, profile definitions, account management and push-notification management. A short summary of the commands is shown below. All devices are identified by their DevEUI (device extended Unique Identifier), hence for any device to be registered to the network it must have valid DevEUI. Devices are always registered uniquely to one account. Device management (add, remove and get status): Get a list of registered devices and their status or status for just one device. Returns basic registration status and downlink FCNT. <code>GET /rest/nodes\nGET /rest/nodes/{deveui}\n</code> Add a new device to OrbiWAN. <code>POST /rest/nodes\n</code> Remove a device from OrbiWAN <code>DELETE /rest/nodes/{deveui}\n</code> Request (PUT) a status update (i.e. LoraWAN DevStatusReq MAC procedure) from the device, and read (GET) the device MAC status. The status includes battery level and link margin of the device. <code>PUT /rest/nodes/{deveui}/status\nGET /rest/nodes/{deveui}/status\n</code> Payload management All payloads sent over LoRaWAN are encrypted and must be encrypted/decrypted by the either the DASS or the applications. Get all the received uplink payloads or just the latest. The payload data returned is by default base64 encoded. Each payload is returned with various additional parameters such as receive timestamp, RSSI, SNR, SF and a unique ID that is used to delete the particular payload when read. <code>GET /rest/nodes/{deveui}/payloads/ul\nGET /rest/nodes/{deveui}/payloads/ul/latest\n</code> Delete uplink payload from the temporary storage. If payloads are not deleted after reading, next read will return the same payload. The ID is the ID returned with the payloads. <code>DELETE /rest/nodes/{deveui}/payloads/ul/{id}\n</code> Send a (encrypted) payload (downlink) to a device. The port and FCNT is provided as part of the URL. The payload must be given directly as base64 encoded data in the HTTP message body: <code>POST /rest/nodes/{deveui}/payloads/dl?fcnt={xx}&amp;port={yy}\n</code> port is the message port for the payload , see [1]. fcnt is the downlink frame counter to be used for the message. In case the internal Join Server in OrbiWAN is used or the AppSKey for the device has been included in the device registration, OrbiWAN can automatically derive the FCNT, hence the FCNT parameter is optional in these cases, and if included the FCNT will be forced to value in the message. The FCNT can be read from the DASS API using the following command: <code>GET /rest/nodes/{deveui}\n</code> This return (with other parameters) the last used FCNT. The next FCNT to use for the downlink is calculated simply by adding +1 to the returned FCNT. Alternatively, an application can keep track of the last used FCNT by register for the downlink push event. Note, as OrbiWAN might send messages to the devices with only LoRa MAC commands, the applications have to use one of the two above methods to keep track of the latest used FCNT. Get status of outstanding downlink message. The ID is the ID returned in the send (POST) command. <code>GET /rest/nodes/{deveui}/payloads/dl/{id}\n</code> Push mode call-back messages To avoid polling for new payloads, status for on-going downlink and device status, the applications can register to receive pushed callback messages when any of the above events happens. Callback message are live messages that are sent immediately when the event happens. Two push schemes are defined. \n  No retry: If a push delivery fails, it will not be repeated but a payload will be stored in the temporary payload storage. If there are payloads already stored in the persistent temporary storage before the push mode is started, the application must manually read out these messages using the pull interface. Already existing payloads and status are not pushed.\n  With retry: continuously push any undelivered payloads to flush the persistent temporary payload storage.\n When a new uplink payload has arrived the DASS will send the payload in a push message: <code>POST /rest/callback/payloads/ul\n</code> The message body will contain a JSON object with the device DevEUI, the actual payload, timestamp and all needed parameters to decrypt it. In the downlink direction once a downlink message transaction has completed and the delivery status is known (i.e. the payload we received or not) the DASS will send: <code>PUT /rest/callback/payloads/dl\n</code> The message body contains a JSON object with the device DevEUI, ID of the downlink payload and status of the delivery. When there is any update on the device (such as an update on the FCNT, change in registration state, etc.) the DASS will send: <code>PUT /rest/callback/nodeinfo\n</code> The message body contains a JSON object with the device information. When a device has updated it device status with battery status and link margin (either requested from the application or unsolicited by the OrbiWAN) the DASS will send: <code>PUT /rest/callback/status\n</code> The message body contains a JSON object with the device status. When a device attempts to join the network with the JOIN procedure, the DASS will send the message to the user application with the join request for the application to authenticate, generate keys, and encrypt the join accept message: <code>PUT /rest/callback/join\n</code> In case the internal Join Server is used, the application will just be notified that a device has joined. The user application can register for push call-back message by sending a registration request to the DASS: <code>PUT /rest/pushmode/start\n</code> The message body must contain a JSON object with the URL of the user application host interface where the DASS will send the push callback messages. When the user’s application no longer want to receive push (e.g. if the application server is being restarted) it must send to the DASS: <code>PUT /rest/pushmode/stop\n</code> Customer registration messages Get a list of registered customers: <code>GET /rest/customers\n</code> Add a new customer. A JSON payload with credentials and rights of the customer must be provided in the message body. <code>POST /rest/customers\n</code> Delete a customer and all users and devices associated with the customer <code>DELETE /rest/customers/customer-id\n</code> User registration messages Get a list of users for a customer: <code>GET /rest/users\n</code> Add a new user to a customer. A JSON payload with credentials and rights of the user is provided to the message body. <code>POST /rest/users\n</code> Delete a user and all associated devices <code>DELETE /rest/customers/user-id\n</code>","url":"rest.html","anchor":"definitions-acronyms-and-abbreviations"},{"objectID":"rest-api-formats","hierarchy_lvl0":"Documentation","hierarchy_lvl1":"REST API","hierarchy_lvl2":"Formats","content":" Formats Query fields and strict option Most of the REST API supported by the DASS also support a number of optional query fields. The query field is placed on the URL after the path with the ‘?’ (question mark) and separated (when more than one is specified) by the ‘&amp;’ (ampersand). One query option that is supported by all APIs is the strict option, e.g.: <code>GET /rest/nodes?strict=true&amp;data_format=hex\n</code> The strict field force the DASS to perform strict parameters checking and will cause a failure on the API if any unknown parameter is provided or if any parameter is missing and that is assigned “hidden” default values.\nThe strict field should NEVER be used in production code, only during development. The DASS API continues to evolve and will continue to introduce new features in a backward compatible way. This often means that default values will be assigned to new fields that are added to the API. An application should ensure to provide all parameters and not rely on “hidden” default values; hence the strict field option can be used during development to check that all fields have been correctly provided. HEX Notation All keys, EUIs and the DevAddr(*) are always represented in HEX notation in all JSON message and in the URL path (in the case of the DevEUI). The ordering of bytes follows the recommendations from the LoRaWAN specification [1]. Three notations are supported (with varies lengths for either DevAddr, DevEUI/AppEUI and keys): <code>\"AAbbCCDD00112233\"\n\"0xAABBccDD00112233\"\n\"AA-BB-CC-dd-00-11-22-33\"\n</code> All HEX notations are case insensitive. Note, for DevAddr it is also possible to specify the address and a decimal number representation of the HEX value. In JSON notation the hex values are represented as strings with quotes (“”) whereas the decimal number is directly represented as a number (i.e. without quotes). Payload data format All payload data provided in either JSON or directly in the message body for a downlink or uplink payload message are always encoded in standard Base64 or HEX representation. Each REST API that take or return payload data accept the ‘data_format’ query field that is used to indicate if the data should be represented in Base64 or HEX. If the data_format is not specified, the default is Base64. The Base64 encoding scheme, encodes binary data into an ASCII text string with each character representing 6-bit of the binary message. This allows inserting the binary payload into a standard string in the JSON message. The Base64 standard encoding scheme is defined in [4]. An example of using the data_format field is: <code>GET /rest/nodes?data_format=hex\n</code> or <code>GET /rest/nodes?data_format=base64\n</code> Error format All REST commands always return a status code. Typically 200 for success and some 4xx error code on failure. In case of error, an error text will often accompany the status code to better explain the precise issue that cause the command to fail. This error text is send as a plain text with the Content-Type field in the http header set to “text/plain”. A typical error message may look like this: <code>\"cannot find device\"\n</code> The DASS also support returning error code in JSON for easier machine parsing. This format is in accordance to RFC 7807. To receive JSON error codes, the client must set the Accept header field to “application/problem+json” to indicate to the DASS that it expect and understand RFC 7807 messages. The DASS will in this case return the error description in JSON and with a Content-Type set to “application/problem+json”. A typical error with JSON may look like this: <code class=\"language-JSON\">{\n    \"type\": \"about:blank\",\n    \"title\": \"cannot find device\",\n    \"detail\": \"cannot find device '1234567812345678'\",\n    \"status\": 404\n}\n</code> Additional fields may be present in JSON object. Please refer to the description of each API.","url":"rest.html","anchor":"formats"},{"objectID":"rest-api-sec:oauth2","hierarchy_lvl0":"Documentation","hierarchy_lvl1":"REST API","hierarchy_lvl2":"OAuth Authentication","content":" OAuth Authentication The DASS API can be used with the basic authentication scheme or the using OAuth2 authentication using a token. The following sections describes how to use the tokens. Obtain an access token To obtain a pair of tokens (access and refresh) the following URL is used. <code>URL: https://dass-host[:port] /rest/oauth2/token?grant_type=password\n                               &amp;client_id={clientid}&amp;username={userid}&amp;password={passwd}\n\nMethod: POST\nDirection: application-&gt;DASS\n</code> Note: while it is possible to make the request directly as query arguments on the URL, this is not safe as URL request may be logged, the request should therefore always be made with the Content-Type set to “application/x-www-form-urlencoded” and the parameters provided in the body of the message. Example : <code>POST https://{host}/rest/oauth2/token?grant_type=password&amp;client_id=my-client&amp;username=my-user&amp;password=my-password\n</code> <code class=\"language-JSON\">{\n    \"access_token\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJjbGllbnRfaWQiOiJkYXNzdWkiLCJleHBpcnlfdGltZSI6MTU2NTc0MDU0NiwicmlnaHRzX21hc2siOjE2Nzc3MjE1LCJ0b2tlbl9pZCI6IjM2MDQxNWZjLTI1OTgtNDkzOC04MjZiLWUwNTEwODgyZDk5YSIsInVzZXJpZCI6ImN1c3QxLXRlbmFudDEiLCJpYXQiOjE1NjU2OTczNDYsImV4cCI6MTU2NTc0MDU0Nn0.KpXLM29Ld4_ztmW2h-WA3Jxy6BDTowyVgr8UBH70ZHE\",\n    \"expires_in\": 43200,\n    \"jti\": \"360415fc-2598-4938-826b-e0510882d99a\",\n    \"refresh_token\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJjbGllbnRfaWQiOiJkYXNzdWkiLCJleHBpcnlfdGltZSI6MTU2NTc0MDU0NiwicmlnaHRzX21hc2siOjE2Nzc3MjE1LCJ0b2tlbl9pZCI6IjM2MDQxNWZjLTI1OTgtNDkzOC04MjZiLWUwNTEwODgyZDk5YSIsInVzZXJpZCI6ImN1c3QxLXRlbmFudDEiLCJpYXQiOjE1NjU2OTczNDZ9.2kp5FeLTGtQy_zBeU20QZyL3EKvZoqUoN2Y6laCOyXs\",\n    \"scope\": \"openid\",\n    \"token_type\": \"bearer\"\n}\n</code> The access_token can subsequently be used to authenticate all other DASS API requests. The refresh_token can only be used to renew the access_token and cannot for API authentication. The access token will expire after a time and a new token must be requested using the refresh_token (see @sec:refreshToken) Return values: \n  \n    \n      Status value\n      Meaning\n      Description\n    \n  \n  \n    \n      200\n      OK\n      JSON with tokens returned in body\n    \n    \n      400\n      Bad request\n      Something is wrong or missing in the request\n    \n    \n      401\n      Unauthorized\n      The username/password used in the authentication scheme is invalid or not present.\n    \n  \n Renew a token The access token returned will expire after a period of time and will need to be renewed. On the initial request to get the token, the refresh_token can be used to request a new pair of tokesn. <code>URL: https://dass-host[:port] /rest/oauth2/token?grant_type=refresh_token&amp;refresh_token={token}\n\nMethod: POST\nDirection: application-&gt;DASS\n</code> Example: <code>POST dass-hostname/rest/oauth2/token?grant_type=refresh_token&amp;refresh_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJjbGllbnRfaWQiOiJkYXNzdWkiLCJleHBpcnlfdGltZSI6MTU1NzUyNjMxNiwicmlnaHRzX21hc2siOjE2Nzc3MjE1LCJ0b2tlbl9pZCI6IjFhMTJjYzhlLTVmZmQtNDgzZC05YmNkLTUyMmNkMjU5MTJlOCIsInVzZXJpZCI6Im9yYml3aXNlIiwiaWF0IjoxNTU3NDgzMTE2fQ.IMVu18Bt1cOunIuisJ4hTal7hPyAiRx-TwhBRqvh_m8\n</code> Returned message body: <code class=\"language-JSON\">{\n    \"access_token\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJjbGllbnRfaWQiOiJkYXNzdWkiLCJleHBpcnlfdGltZSI6MTU2NTc0MDU0NiwicmlnaHRzX21hc2siOjE2Nzc3MjE1LCJ0b2tlbl9pZCI6IjM2MDQxNWZjLTI1OTgtNDkzOC04MjZiLWUwNTEwODgyZDk5YSIsInVzZXJpZCI6ImN1c3QxLXRlbmFudDEiLCJpYXQiOjE1NjU2OTczNDYsImV4cCI6MTU2NTc0MDU0Nn0.KpXLM29Ld4_ztmW2h-WA3Jxy6BDTowyVgr8UBH70ZHE\",\n    \"expires_in\": 43200,\n    \"jti\": \"360415fc-2598-4938-826b-e0510882d99a\",\n    \"refresh_token\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJjbGllbnRfaWQiOiJkYXNzdWkiLCJleHBpcnlfdGltZSI6MTU2NTc0MDU0NiwicmlnaHRzX21hc2siOjE2Nzc3MjE1LCJ0b2tlbl9pZCI6IjM2MDQxNWZjLTI1OTgtNDkzOC04MjZiLWUwNTEwODgyZDk5YSIsInVzZXJpZCI6ImN1c3QxLXRlbmFudDEiLCJpYXQiOjE1NjU2OTczNDZ9.2kp5FeLTGtQy_zBeU20QZyL3EKvZoqUoN2Y6laCOyXs\",\n    \"scope\": \"openid\",\n    \"token_type\": \"bearer\"\n}\n</code> \n  \n    \n      Status value\n      Meaning\n      Description\n    \n  \n  \n    \n      200\n      OK\n      JSON with tokens returned in body\n    \n    \n      400\n      Bad request\n      Something is wrong or missing in the request\n    \n    \n      401\n      Unauthorized\n      the refresh_token is expired or not valid\n    \n  \n Obtain Application token Tokens for application sub-accounts can be obtained just like for normal user accounts but there is also an convenience API to obtain a token for an application directly from the master account. <code>URL: https://dass-host[:port] /rest/applications/{application-id}/oauth2/token\n\nMethod: POST\nDirection: application-&gt;DASS\n</code> Calling this API requires no arguments and will return the same JSON message with the tokens as described in the above API. \n  \n    \n      Status value\n      Meaning\n      Description\n    \n  \n  \n    \n      200\n      OK\n      JSON with tokens returned in body\n    \n    \n      400\n      Bad request\n      Something is wrong in the request\n    \n    \n      401\n      Unauthorized\n      the username/password or token used to authenticate the request is wrong.\n    \n  \n","url":"rest.html","anchor":"sec:oauth2"},{"objectID":"rest-api-device-management---detailed-description","hierarchy_lvl0":"Documentation","hierarchy_lvl1":"REST API","hierarchy_lvl2":"Device management - detailed description","content":" Device management - detailed description This section describes the details of each message. Register a Device Register a new device on the DASS/RNSS. <code>URL: https://host[:port]/rest/nodes\n</code> Method: POST \nDirection: Application-&gt;DASS The message content of the registration message depend on the whether the devices is being registered using device-profile (and service-profile) or if the device is being registered using the direct registration (legacy method of registration prior to release 6). The API to register devices either way is the same, however the message content is different. When using profiles, the number of fields needed to register a device is far less than when doing direct registration. The following show the registration message object to fill when using profile. The values shown are examples but are typically the default value (if the field is not specified). <code class=\"language-JSON\">{\n    \"deveui\": \"AA-BB-CC-dd-00-11-22-33\",\n    \"lora_device_class\": 0,\n    \"appeui\": \"\",\n    \"joineui\": \"\",\n    \"appkey\": \"\",\n    \"nwkkey\": \"\",\n    \"nwkskey\": \"\",\n    \"snwksintkey\": \"\",\n    \"fnwksintkey\": \"\",\n    \"nwksenckey\": \"\",\n    \"appskey\": \"\",\n    \"applications\": \"\",\n    \"groups\": \"\",\n    \"userid\": \"\",\n    \"comment\": \"\",\n    \"altitude\": 0,\n    \"latitude\": 0,\n    \"longitude\": 0,\n    \"options\": 0,\n    \"activated\": true,\n    \"device_profile_uuid\": \"\",\n    \"service_profile_uuid\": \"\"\n}\n\n</code> Note, which keys that need to be provided depends on whether the device is being activated via ABP or OTAA, and whether the device is compliant to LoraWAN MAC version 1.0.x or 1.1.x. Please see table at end of section for explanation on which keys to provide. The device registration message parameters are described in the table below: \n  \n    \n      Field\n      type\n      Description\n    \n  \n  \n    \n      deveui\n      string\n      Device Extended Unique Identifier (DevEUI).Mandatory.\n    \n    \n      lora_device_class\n      number\n      Active device class of the deviceOptional. Valid range: [0;2]\n    \n    \n      appeui\n      string\n      Application EUI of device.This field should almost never be provided, but can be specified to make it look like a ABP device also have an AppEUI for legacy applications that require to receive a valid AppEUIOptional.\n    \n    \n      joineui\n      string\n      JoinEUI override of OTAA device.This field can be specified to override the the AppEUI/JoinEUI sent by the device during the JOIN procedure. This is used to direct the JOIN ACCEPT to a registered Join Server that doesn’t match the range of the JoinEUI embedded in the actual device.Optional.\n    \n    \n      appkey\n      string\n      AppKey of the device.The application key is optional and may be ommitted if the device key is stored in an external key store, or if the JOIN procedure is managed by the applicationOptional.\n    \n    \n      nwkkey\n      string\n      NwkKey of of device (for OTAA activation mode and LoraMac 1.1.x only)Optional.\n    \n    \n      nwkskey\n      string\n      Network Session Key (for ABP activation mode and LoraMac 1.0.x only)Optional.\n    \n    \n      snwksintkey\n      string\n      Serving Network Session Integretry key (for ABP activation mode and LoraMac 1.1.x only)Optional.\n    \n    \n      fnwksintkey\n      string\n      Forwarding Network Session Integretry key (for ABP activation mode and LoraMac 1.1.x only)Optional.\n    \n    \n      nwksenckey\n      string\n      Network Session Encryption key (for ABP activation mode and LoraMac 1.1.x only)Optional.\n    \n    \n      appskey\n      string\n      Application Session Key (for ABP activation mode)Optional.\n    \n    \n      applications\n      string\n      Application accounts associated with this deviceOptional.\n    \n    \n      groups\n      string\n      Groups associated with this deviceOptional.\n    \n    \n      userid\n      string\n      The account ID of the account owning the device.This parameters cannot not be set on creation but can be changed later by administrator accounts.Optional.\n    \n    \n      comment\n      string\n      Device user commentOptional.\n    \n    \n      altitude\n      number\n      Altitude of device [m]Optional.\n    \n    \n      latitude\n      number\n      Latitude of device [deg]Optional.\n    \n    \n      longitude\n      number\n      Longitude of device [deg]Optional.\n    \n    \n      options\n      number\n      Options fieldThis field should only be used when specifically requested by the operator. Can be omitted or set to zeroOptional.\n    \n    \n      activated\n      boolean\n      Device activated.When the device is activated the device will operate normally on the netowrk. When not activated, the network will not allow up and downlink from the device.Optional.\n    \n    \n      device_profile_uuid\n      string\n      Device Profile UUIDMandatory.\n    \n    \n      service_profile_uuid\n      string\n      Service Profile UUIDMandatory.\n    \n  \n When registering the device using direct registration (also known as the legacy registration method), profiles are not used and additional information about the device need to be provided directly in the registration message. The registration message object for direct registration is shown below: <code class=\"language-JSON\">{\n    \"lora_device_class\": 0,\n    \"deveui\": \"AA-BB-CC-dd-00-11-22-33\",\n    \"appeui\": \"\",\n    \"joineui\": \"\",\n    \"appkey\": \"\",\n    \"nwkkey\": \"\",\n    \"nwkskey\": \"\",\n    \"snwksintkey\": \"\",\n    \"fnwksintkey\": \"\",\n    \"nwksenckey\": \"\",\n    \"appskey\": \"\",\n    \"groups\": \"\",\n    \"applications\": \"\",\n    \"userid\": \"\",\n    \"lora_fcnt_32bit\": false,\n    \"lora_rx_delay1\": 1,\n    \"lora_rx_delay2\": 2,\n    \"lora_major\": 0,\n    \"lora_rx2_sf\": \"\",\n    \"comment\": \"\",\n    \"expiry_time_uplink\": 168,\n    \"expiry_time_downlink\": 168,\n    \"redundant_uplink_cnt\": 0,\n    \"device_properties\": \"\",\n    \"options\": 0,\n    \"max_allowed_dutycycle\": 0,\n    \"expected_avr_dutycycle\": 0,\n    \"latitude\": 0,\n    \"longitude\": 0,\n    \"altitude\": 0,\n    \"activation\": \"\",\n    \"lora_location\": false,\n    \"activated\": true,\n    \"downlink_allowed\": true,\n    \"MACVersion\": \"1.0.1\",\n    \"RegParamsRevision\": \"A\",\n    \"MaxEIRP\": 16,\n    \"RFRegion\": \"default region of the network\"\n}\n\n</code> The device registration message parameters for the direct (legacy) registration method are described in the table below: \n  \n    \n      Field\n      type\n      Description\n    \n  \n  \n    \n      lora_device_class\n      integer\n      Active device class of the deviceMandatory. Valid range: [0;2]\n    \n    \n      deveui\n      string\n      Device Extended Unique Identifier (DevEUI)Mandatory.\n    \n    \n      appeui\n      string\n      Application EUI key of deviceThis field should almost never be provided, but can be specified to make it look like a ABP device also have an AppEUI for legacy applications that require to receive a valid AppEUIOptional.\n    \n    \n      joineui\n      string\n      JoinEUI override of OTAA deviceThis field can be specified to override the the AppEUI/JoinEUI sent by the device during the JOIN procedure. This is used to direct the JOIN ACCEPT to a registered Join Server that doesn’t match the range of the JoinEUI embedded in the actual device.Optional.\n    \n    \n      appkey\n      string\n      AppKey of the deviceThe application key is optional and may be ommitted if the device key is stored in an external key store, or if the JOIN procedure is managed by the applicationOptional.\n    \n    \n      nwkkey\n      string\n      NwkKey of of device (for OTAA activation mode and LoraMac 1.1.x only)Optional.\n    \n    \n      nwkskey\n      string\n      Network Session Key (for ABP activation mode and LoraMac 1.0.x only)Optional.\n    \n    \n      snwksintkey\n      string\n      Serving Network Session Integretry key (for ABP activation mode and LoraMac 1.1.x only)Optional.\n    \n    \n      fnwksintkey\n      string\n      Forwarding Network Session Integretry key (for ABP activation mode and LoraMac 1.1.x only)Optional.\n    \n    \n      nwksenckey\n      string\n      Network Session Encryption key (for ABP activation mode and LoraMac 1.1.x only)Optional.\n    \n    \n      appskey\n      string\n      Application Session Key (for ABP activation mode)Optional.\n    \n    \n      groups\n      string\n      Groups associated with this deviceOptional.\n    \n    \n      applications\n      string\n      Application accounts associated with this deviceOptional.\n    \n    \n      userid\n      string\n      The account ID of the account owning the device.This parameters cannot not be set on creation but can be changed later by administrator accounts.Optional.\n    \n    \n      lora_fcnt_32bit\n      boolean\n      Use 32-bit FCNT in the LoraMac frames (LoraMac 1.0.x only)Mandatory.\n    \n    \n      lora_rx_delay1\n      integer\n      RX window 1 delay [seconds]Optional. Valid range: [1;5]\n    \n    \n      lora_rx_delay2\n      integer\n      RX window 2 delay [seconds]If specified, must be set to RX window 1 delay + 1 secondOptional. Valid range: [2;6]\n    \n    \n      lora_major\n      integer\n      Lora Major number. Must be zeroOptional. Valid range: [0;0]\n    \n    \n      lora_rx2_sf\n      string\n      Initial spreading factor of RX slot 2Mandatory.\n    \n    \n      comment\n      string\n      Device user commentOptional.\n    \n    \n      expiry_time_uplink\n      number\n      Uplink payloads expiry time [hours]Optional. Valid range: [1;1000000]\n    \n    \n      expiry_time_downlink\n      number\n      Downlink payloads expiry time [hours]Optional. Valid range: [1;1000000]\n    \n    \n      redundant_uplink_cnt\n      integer\n      Device uplink redundancy overrideShould be normally be ommited. Values are 0: let network decide, 1: use one transmission per uplink (no redundancy), 2-8: use 2-8 transmissions per uplinkOptional. Valid range: [0;6]\n    \n    \n      device_properties\n      string\n      Device propertiescomma separated string with properties. The supported properties are: static,mobile,indoor,outdoorOptional.\n    \n    \n      options\n      integer\n      Options fieldThis field should only be used when specifically requested by the operator. Can be omitted or set to zeroOptional.\n    \n    \n      max_allowed_dutycycle\n      number\n      Maximum allowed dutycycle in percent [%]Optional. Valid range: [0;100]\n    \n    \n      expected_avr_dutycycle\n      number\n      expected dutycycle of device [%]Optional. Valid range: [0;100]\n    \n    \n      latitude\n      number\n      Latitude of device [deg]Optional.\n    \n    \n      longitude\n      number\n      Longitude of device [deg]Optional.\n    \n    \n      altitude\n      number\n      Altitude of device [m]Optional.\n    \n    \n      activation\n      string\n      Activation mode of the deviceValid options are ABP (Activation By Personalisation) or OTAA (Over The Air Activation).Optional.\n    \n    \n      lora_location\n      boolean\n      Enable Lora based location estimation.Optional.\n    \n    \n      activated\n      boolean\n      Device activated.When the device is activated the device will operate normally on the netowrk. When not activated, the network will not allow up and downlink from the device.Optional.\n    \n    \n      downlink_allowed\n      boolean\n      Downlink allowedOptional.\n    \n    \n      MACVersion\n      string\n      Version of LoraWAN MAC that the device is compliant toOptional. Valid values: “1.0.1”, “1.1.1”\n    \n    \n      RegParamsRevision\n      string\n      Revision of LoraWAN MAC that the device is compliant toNote, only some versions of the LoraWAN MAC have revisionsOptional. Valid values: “A”, “B”\n    \n    \n      MaxEIRP\n      number\n      Max Equivalent Isotropically Radiated Power (EIRP) of device [dBm]This is only applicable to 1.0.2 Rev B or later deviceOptional. Valid range: [0;33]\n    \n    \n      RFRegion\n      string\n      Region of the deviceOptional. Valid values: “EU868”, “US915”, “CN779”, “EU433”, “AU915”, “CN470”, “AS923”, “AS923-2”, “AS923-3”, “KR920”, “IN865”, “RU864”, “JP923”, “China779”, “Australia915”, “China470”, “INDIA”\n    \n  \n The expiry_time_uplink and expiry_time_downlink is the time in hours an up- or downlink payload will stay in the persistent temporary storage if the DASS or application does not delete it. The downlink expiry time is independent of whether the messages has been sent or not. The device_properties field is a string with comma-separated properties that best describe the device. These properties are used by the network to improve the overall quality of server in the entire system. The following properties are currently supported. \n  \n    \n      Property name\n      Description\n    \n  \n  \n    \n      “static”\n      The device is installed in a fixed position and does not move.\n    \n    \n      “mobile”\n      The device can move around\n    \n    \n      “indoor”\n      The device is generally used indoors\n    \n    \n      “outdoor”\n      The device is generally used outdoors.\n    \n  \n Examples: <code class=\"language-JSON\">Valid combinations:\n    \"device_properties\": \"static,indoor\",\n    \"device_properties\": \"mobile\",\n\nIllegal combinations:\n    \"device_properties\": \"static,mobile\",\n</code> Key schemes Common for both registration methods (profiles or direct) are the device key fields and the DevEUI and DevAddr fields. The DevEUI must be unique per device, a DevAddr can be assigned to multiple devices, but the DevAddr + NwkSKey pair must be unique. The presence of the appkey, nwkkey, appskey, nwkskey, snwksintkey, fnwksintkey, nwksenckey, and devaddr depends on the type of device activation mode used, the level of security required (i.e. who have access to the master key), and the version of the LoraWAN MAC the device is compliant to. Using OrbiWAN internal Join-Server, OTAA devices. When using the OTAA activation mode, the AppKey (and NwkKey for LoraWAN 1.1.x devices) can be either registered on the DASS such that the internal JOIN Server (JS) will manage the JOIN procedure. In this case the AppKey (and NwkKey) must be registered on the device. In this case the DASS will also manage all encryption/decryption of payload messages. Data send/received on the DASS API will not be LoRaWAN encrypted, but still protected by HTTPS. ABP activation When an external JS is used (or the JOIN is managed directly by the Application) the AppKey (and NwkKey) is kept outside of the DASS and the keys are not provided to the DASS. In this case the DASS will automatically invoke the JS (or application) to process the JOIN procedure. In this case the DASS will not be able to manage the payload encryption/decryption and will parse directly the raw encrypted payload messaged for the application to manage the encryption/decryption. When using ABP activation mode all “network session” keys must be provided. However the AppSKey is optional, and if provide the DASS will automatically manage all payload encryption/decryption. When not present the DASS will “pass-through” the raw encryption payload messages in both up and downlink. The following combinations are supported, requiring the indicated keys: \n  \n    \n      Activation scheme\n      Mac Version\n      External JS\n      AppKey\n      AppSKey\n      NwkKey\n      DevAddr\n      NwkSKey\n      SNwkSIntKey\n      FNwkSIntKey\n      NwkSEncKey\n    \n  \n  \n    \n      OTAA\n      1.0.x\n      no\n      X\n       \n       \n       \n       \n       \n       \n       \n    \n    \n      OTAA\n      1.1.x\n      no\n      [X]\n       \n      X\n       \n       \n       \n       \n       \n    \n    \n      OTAA\n      1.0.x\n      yes\n       \n       \n       \n       \n       \n       \n       \n       \n    \n    \n      OTAA\n      1.1.x\n      yes\n       \n       \n      X\n       \n       \n       \n       \n       \n    \n    \n      ABP\n      1.0.x\n       \n       \n      [X]\n       \n      X\n      X\n       \n       \n       \n    \n    \n      ABP\n      1.1.x\n       \n       \n      [X]\n       \n      X\n       \n      X\n      X\n      X\n    \n  \n Note, in the case of OTAA on MAC 1.1.x, the AppKey is optional. In this case the DASS will manage all key derivation for the network on the JOIN message, but will forward also the raw JOIN message to the application (via pushmode notification). The application must then itself derive the AppSKey from the JOIN and perform all payload encryption/decryption. Groups and Applications Each device can be associated with multiple groups and applications. The association is set directly by specifying directly the comma separated list of groups, e.g.: <code>    \"groups\": \"groupid1,groupid3\"\n</code> This applies to both lists, i.e. groups and applications. Return values for device registration: \n  \n    \n      Status value\n      Meaning\n      Description\n    \n  \n  \n    \n      200\n      OK\n      Registration was successful\n    \n    \n      401\n      Unauthorized\n      The username/password used in the basic authentication scheme is invalid or not present.\n    \n    \n      404\n      Error in registration\n      One or more of the parameters are invalid. Possible causes for this error are: devaddr + nwkskey pair already used, missing parameters in the message.\n    \n    \n      406\n      Not Acceptable\n      Some of the parameters are not valid (e.g. wrong key length, etc).\n    \n    \n      409\n      Already registered\n      The device (based on the DevEUI) was already registered on the network. No values have been updated. If a device needs to be registered with new values, the device must be deleted first before being added again.\n    \n  \n Get Device Info Get information on a registered device. <code>    URL: https://host[:port]/rest/nodes/{deveui}\n</code> Optional query fields: strict=[true,false], all=[true,false] \nMethod: GET \nDirection: Application-&gt;DASS The command returns a message with a JSON payload with the following field: <code class=\"language-JSON\">{\n    \"device_status\": 3, // 0: registered but never seen,\n                        // 1: seen, but with MIC error,\n                        // 2: JOIN’ed (for JOIN devices only),\n                        // 3: successfully received uplink\n\n    \"last_reception\": \"timestamp\", // time when device was last seen\n    \"dl_fcnt\": 45,                // 0: class A, 1: class B, 2: class C\n    \"registration_status\": 1,     // 0: pending RNSS registration,\n                                  // 1: registered, 2: pending RNSS\n                                  // deregistration\n    \"deveui\": \"deveui in hex\",    // DevEUI of device in HEX\n    \"expiry_time_uplink\": 168,    // ul payload expiry time in hours\n    \"expiry_time_downlink\": 168,  // dl payload expiry time in hours\n\n    \"latitude\": 45,\n    \"longitude\": 22,\n    \"loraloc_time\": \"timestamp\",    // time of last location estimate\n    \"loraloc_fcnt\": 123             // FCNT of last uplink used in\n                                    // location estimate\n}\n</code> The timestamp is in ISO 8601 format “yyyy-mm-ddThh:mm:ss.SSSZ” format (where SSS is in milliseconds) and aligned with UTC time. To read back the complete set registration parameters (as defined in @sec:deviceRegistration) for the device, specify the all option, i.e. <code>    https://host[:port]/rest/nodes/{deveui}?all=true\n</code> Reading back the complete registration message is significantly slower that just reading the standard message, the all field should therefore only be used when needed, and not when e.g. just querying for the current FCNT. Return values: \n  \n    \n      Status value\n      Meaning\n      Description\n    \n  \n  \n    \n      200\n      OK\n      Request ok, the above JSON message is received in the message body\n    \n    \n      401\n      Unauthorized\n      The username/password used in the basic authentication scheme is invalid or not present.\n    \n    \n      404\n      Unknown device\n      The DevEUI is not known\n    \n  \n Update / Modify device registration Modify the parameters on a registered device on the DASS/RNSS. <code>    URL: https://host[:port]/rest/nodes/{deveui}\n    URL: https://host[:port]/rest/nodes/{groupid}\n</code> Method: PUT \nDirection: Application-&gt;DASS This command can be used to modify any parameter of device already registered on the DASS. This command can be used to modify a single device by specifying its deveui in the URL, but it is also possible to perform a multi-device update by specifying a group id in the URL. In this case the modification will be applied to all devices in the group. Note, when using large groups, the command can take long to complete. The typical usages are to change the device operation mode between class A and class C, update the static position of the device, update the name, etc. But any parameter can be change, except the DevEUI. Warning: If parameters such as the keys, DevAddr, RX slot timing and RX slot spreading factor are changed there is a risk communication is lost to the device. The command takes a JSON payload with the parameters from the JSON object in the registration message described in @sec:deviceRegistration. Only the fields that are being changed should be included in the JSON object. The DevEUI cannot be change and should not be specified in the JSON object. Example: o modify the device class and update the device name the following JSON object would be used: <code class=\"language-JSON\">    {\n        \"comment\": \"now a class C device\",\n        \"lora_device_class\": 2\n    }\n</code> Note, when updating either the devaddr or the nwkskey, both parameters must always be updated together, it is not allowed to update either alone. For groups and applications, the list can be set directly as for registration to replace all current associations, e.g.: <code>\"groups\": \"groupid1,groupid3\"\n</code> But it is also possible to perform a modification such as adding one group to the existing list. This is useful when modifying devices via the multi-device group update. In this way, a group can be added or removed without affecting any other associated groups. To add a group, prefix the group name with a plus ‘’+”, e.g.: <code>\"groups\": \"+groupid3\"\n</code> This will add groupid3 to the list of groups, not affecting what is already in the list. Similarly a group can be removed from the device using the minus “-“ prefix, e.g.: <code>\"groups\": \"-groupid3\"\n</code> This applies to both lists, groups and to applications. It is possible to change the owning user of a device. To move a device or group of devices to another account, the field “userid” can be set in the message body with the name of the user account that should become the owner of the device(s).\nDevices can be moved between both user and customer accounts freely. E.g. <code class=\"language-JSON\">{\n    \"userid\": \"{userid}\"\n}\n</code> After modifying a device or group of devices this way, it is no longer possible to access the device on the old account. It is possible to combine the modification with any other fields from above. Associated groups and application will automatically be removed from the device during the move to the new account, as the groups and application belongs to the old account. When changing the owner of a device, the target groups and applications for the device on the new account can be set in the same command. When the userid field is used in the message, the scope for the applications and groups fields automatically relate to the new account. E.g.: <code class=\"language-JSON\">{\n    \"userid\": \"{userid2}\",\n    \"groups\": \"group1-userid2, group2-userid2\",\n    \"applications\": \"app1-userid2, app2-userid2\"\n}\n</code> Note: when changing userid, setting the +/- modifies on groups and applications are not allowed. Changing owner of a device to another account within the same customer, can only be done from an account with user admin rights. Changing owner from a user account (or customer account) to another user in a different customer can only be done from an account with customer admin rights. Return values: \n  \n    \n      Status value\n      Meaning\n      Description\n    \n  \n  \n    \n      200\n      OK\n      Modification was successful\n    \n    \n      202\n      Accepted\n      The command was accepted, and at least one device was updated, but at least one devices failed to update.\n    \n    \n      401\n      Unauthorized\n      The username/password used in the basic authentication scheme is invalid or not present.\n    \n    \n      403\n      Forbidden\n      The user does not have the rights to modify the parameter\n    \n    \n      400\n      Error in update\n      One or more of the parameters are invalid.\n    \n    \n      406\n      Not Acceptable\n      Some of the parameters are not valid (e.g. wrong key length, etc).\n    \n  \n Node in case of multi-device update (either update via group, or multiple targets in URL), when 202 or 406 status code is present, it is possible to see a list of which devices failed and the reason for the failure. This information is available when using the “application/problem+json” error format (see section @sec:errorFormat). The error object will look as follows: <code class=\"language-JSON\">{\n    \"type\": \"about:blank\",\n    \"status\": 202 or 406,\n    \"title\": ...,\n    \"detail\": ...,\n    \"failed-devices\": [\n        { \"reason\": \"reason 1\", \"deveuis\": [\"1234567800000001\", \"1234567800000002\"] },\n        { \"reason\": \"reason 2\", \"deveuis\": [\"1234567800000003\"] }\n    ]\n}\n</code> In the above example three devices failed for two separate reasons. The “failed-devices” array will have an entry for each of the encountered reason for failure, and list the DevEUIs of each failed device in the section for the different reasons. Get List of Devices Get list of registered devices with the device info for each device. URL: https://host[:port]/rest/nodes[?[group=groupid][&amp;application=appid1]] Method: GET \nDirection: Application-&gt;DASS The request returns an array of device info objects (see description of object in @sec:getDevice): <code class=\"language-JSON\">[\n    {\"device_status\": 3, \"last_reception\": \"timestamp\", \"dl_fcnt\": 45,\n    \"device_class\": 0, \"registration_status\": 1, \"deveui\": \"deveui in hex\", \"appeui\": \"HEX\"},\n\n    {\"device_status\": 3, \"last_reception\": \"timestamp\", \"dl_fcnt\": 45,\n    \"device_class\": 0, \"registration_status\": 1, \"deveui\": \"deveui in hex\", \"appeui\":\"HEX \"},\n\n    ...\n]\n</code> The list can be filtered by the following query filters: \n  group={group-id}, when this query is set, only the devices associated to the specified group is returned.\n  application={app-id}, when this query is set, the devices associated to the specified application is returned.\n  search_comment=text, will filter the devices according to the text string. The text is automatically “wildcarded” at both ends.\n  search_deveui=partial_deveui, text search of partial deveui\n  from_date={ISO8601-date-string}, return device with an update from ISO timestamp and forward.\n  to_date={ISO8601-date-string}, return device with an update from before the given timestamp.\n In addition, special queries can be used to help the pagination. These queries can be combined with the above filters. \n  limit={max-num-devices}, set maximum number of devices returned. Used for paging\n  get_pages=true is normally combined with “limit=xx” (which set the page size) and will return a table with the page state of each page allowing “random access” to all pages. This is typically use in UI to be able to put paging button on a table.\n  page_state=page_state_info. Read from page where the page_state_info is provided as the page_state fields of the special get_pages query. Note the string must be copied exactly as returned from the get_pages query.\n  paged_results=true, returns the query result and addition page state information to be able to read the next page.\n Sorting of the result can be specified in the following query options: \n  \n    \n      \n        \n          **sort_by_deveui=asc\n          desc\n          true**, sort the output ascending or descending (true=ascending for backward compatibility) by the deveui.\n        \n      \n    \n  \n  \n    \n      \n        \n          **soft_by_comment=asc\n          desc\n          true**, sort the output ascending or descending (true=ascending) by the device comment.\n        \n      \n    \n  \n  \n    \n      \n        \n          **sort_by_date=asc\n          desc\n          true**, sort the output ascending or descending (true=ascending) by the last update (which is when the last uplink was received).\n        \n      \n    \n  \n When the get_pages=true query is used, the following object is returned: <code class=\"language-JSON\">{\n    \"total\": 1121,\n    \"per_page\": 2000,\n    \"pages\": [\n        { \"page_state\": \"xxxxxx\" },\n        ...\n    ]\n}\n</code> For backward compatibility the result of a query is directly an array with the results. However, when using paged queries unless the entire page state table has been acquired by the “get_pages=true” command, it is necessary to receive the page state at the end of each page to be able to query the next one. To receive the page state in the result set the “paged_results=true” option. With this option the result from a query has the following format: <code class=\"language-JSON\">{\n    \"results\": [\n        ...\n    ],\n    \"next_page_state\": \"xxxxxx\"\n}\n</code> Note: when using sorting there are some limitation that must be observed. Sorting on some columns (e.g. the deveui) is always supported and can be queried directly in a page-by-page fashion. However when sorting on other columns it may not be possible to query the pages in this way. In this case a query with the “get_pages=true” option must be used. This returns the table with all page states. From this table it is possible to start querying the first page using the returned page state from that page. Sub-sequently it is possible to go page-by-page using the next_page_state state, or to use the table that was returned by the “get_pages=true” query. It is always safe to “try” to query the first page without the page state. If it is supported the page will be returned, if not supported an error 416 is returned. When this error is received, the application knows that it must first use the “get_pages=true” query to get the page states. For accounts with a lot of devices (e.g several 100k devices) sorting by some columns will be restricted. If there is too much data to sort an error 413 is returned. In this case the user must either specify more filtering so limit the data set, or must disable sorting or sort via the safe deveui sorting column. The returned page states may expire after a while, and if trying to access or reload a page with an expired page state will return 410. In this case the application need to reload again from first page, or use the “get_pages=true” option to get the update-to-date page states. Return values: \n  \n    \n      Status value\n      Meaning\n      Description\n    \n  \n  \n    \n      200\n      OK\n      Request ok, the above JSON message is received in the message body\n    \n    \n      400\n      Error in query\n      There is an error in the query fields\n    \n    \n      401\n      Unauthorized\n      The username/password used in the basic authentication scheme is invalid or not present.\n    \n    \n      404\n      Not found\n      The specified filter refer to unknown resource\n    \n    \n      410\n      Page expired\n      returned when the page_state field is used and the page is expired\n    \n    \n      413\n      Too big query\n      When using sorting and there are too many records in the result, this error is returned. In this case avoid to use sorting on that particular field.\n    \n    \n      416\n      Page state reqired\n      A page state is required to be able to query with the particular sorting option. Get the page states with a query with get_pages=true.\n    \n  \n Delete Device from OrbiWAN Deregister a device from the OrbiWAN. Note that the successful return of this command means that the request has been accepted and is valid. The actual device de-registration and deletion from internal databases can take several seconds to complete. There is therefore a chance that, if the same device is being registered again immediately after the de-registration, the re-registration may fail.\nTo see that a device have been completely deleted a query on the device with the GET device Info command (see @sec:getDevice) can be used and should return with a error 404. <code>URL: https://host[:port]/rest/nodes/{deveui}\n</code> Method: DELETE \nDirection: Application-&gt;DASS Return values: \n  \n    \n      Status value\n      Meaning\n      Description\n    \n  \n  \n    \n      200\n      OK\n      Delete was successful\n    \n    \n      401\n      Unauthorized\n      The username/password used in the basic authentication scheme is invalid or not present.\n    \n    \n      404\n      Unknown device\n      The DevEUI is not known\n    \n  \n Request Device Status Procedure Request the OrbiWAN to perform the LoraWAN DevStatusReq MAC procedure (see section 5.5 “Device Status” in [1]). he procedure will be performed by the OrbiWAN on the tail of the next device uplink. The result will be available from the device on the uplink again after that. Hence the procedure can take as long as the duration of two normally scheduled uplink periods from a device, and the results may not be available for hours or even days depending on the uplink period of the device. <code>URL: https://host[:port]/rest/nodes/{deveui}/status\n</code> Method: PUT \nDirection: Application-&gt;DASS Return values: Status value    Meaning    Description\n200    OK    Request was accepted. A DevStatusReq will be sent to the device on the next opportunity.\n401    Unauthorized     The username/password used in the basic authentication scheme is invalid or not present.\n404    Unknown device    The DevEUI is not known Read Device Status Procedure Result Read the result from a completed DevStatusReq MAC procedure (see previous section). <code>URL: https://host[:port]/rest/nodes/{deveui}/status\n</code> Method: GET \nDirection: Application-&gt;DASS The following JSON object is returned: <code class=\"language-JSON\">{\n    \"battery_status\": 0,    // value from LoraWAN specification,\n                            // 0: connected to power source,\n                            // 1..254: battery level 1 being minimum and\n                            // 254 being maximum,\n                            // 255:not possible for the device to measure\n                            // battery level\n    \"margin_status\": 0,     // demodulation SNR [dB]for the\n                            // DevStatusReq command.\n    \"timestamp_status\": \"2015-02-06T10:43:23.331Z\",// GMT time of last report\n    \"req_status\": 2         // 0: never updated, 1: update requested,\n                            // 2: request pending, 3: result ready\n}\n</code> The values can be considered valid only when the req_status field has a value of 3 (meaning result ready). The timestamp is in ISO 8601 format “yyyy-mm-ddThh:mm:ss.SSSZ” format (where SSS is in milliseconds) and aligned with UTC. Return values: \n  \n    \n      Status value\n      Meaning\n      Description\n    \n  \n  \n    \n      200\n      OK\n      Request was OK. The above explained JSON object is returned in the message body.\n    \n    \n      401\n      Unauthorized\n      The username/password used in the basic authentication scheme is invalid or not present.\n    \n    \n      404\n      Unknown device\n      The DevEUI is not known\n    \n  \n","url":"rest.html","anchor":"device-management---detailed-description"},{"objectID":"rest-api-payload-management--detailed-description","hierarchy_lvl0":"Documentation","hierarchy_lvl1":"REST API","hierarchy_lvl2":"Payload Management – Detailed Description","content":" Payload Management – Detailed Description Receive all Pending Uplink Payloads from Device Receive an array with all received payloads for a device. The payloads are stored in the persistent temporary storage inside OrbiWAN. The application should delete the payload once they have been safely “consumed”. Unread payloads will be automatically deleted after an expiry period. <code>URL: https://host[:port]/rest/nodes/{deveui}/payloads/ul[?query_options]\n</code> Method: GET \nDirection: Application-&gt;DASS The valid queries that can be used with this API are: \n  \n    \n      Parameter\n      values\n      description\n    \n  \n  \n    \n      data_format\n      hex,base64\n      Data format for all binary data. Default is base64\n    \n    \n      from_date\n      ISO8601 date/time\n      show only payload from after this time/date\n    \n    \n      to_date\n      ISO8601 date/time\n      show only payload from before time/date\n    \n    \n      get_pages\n      boolean\n      see section on paged queries\n    \n    \n      limit\n      number\n      see section on paged queries\n    \n    \n      page_state\n      string\n      see section on paged queries\n    \n    \n      paged_results\n      boolean\n      see section on paged queries\n    \n    \n      mac_msg\n      boolean\n      when true and user has rights to see MAC message, the returned list of payloads will include the raw LoRaWAN Mac frames. Default is false.\n    \n    \n      search_port\n      string\n      filter by port number. Port can be composed of comma separated ranges. E.g. “1-10,50-55,100,200-“ will return payloads with port values from 1 to 10 and 50 to 55, 100 and 200 to 255. When the range ‘-‘ is left open, e.g. 100- or -50 it means from 100 to 255 or from 0 to 50 respectively.\n    \n    \n      sort_by_timestamp\n      asc,desc\n      Sort the payloads by the timestamp ascending or descending.\n    \n    \n      strict\n      boolean\n      enforce strict checking of all parameters\n    \n    \n      locations\n      boolean\n      include estimated location (latitude, longitude, altitude) in results. Note, the fields are only included in the message if a location estimate is available, and the altitude will normally not be available as most locations solver will not estimate the altitude.\n    \n    \n      push_status\n      boolean\n      include push_status array with status of the push attempt to each application\n    \n    \n      search_pushfail\n      boolean\n      filter the payloads and return only the payloads that failed pushing the data to the an application.\n    \n    \n      search_pushfail_app\n      app-id\n      filter the payloads and return only the payloads that failed pushing the data to the specified application.\n    \n  \n [DMM] the above push_status and search_pushfail is part of DMM. A JSON message body is returned with an array of all payloads <code class=\"language-JSON\">    [\n        {\n            \"dataFrame\": \"AB==\",\t// raw (encrypted) payload in base64 format\n            \"confirmed\": false,     // confirmed(true) or unconfirmed(false) uplink\n            \"port\": 1,\t\t        // MAC port the message was receive on\n            \"timestamp\": \"2015-02-11T10:33:00.578Z\",\t// time of reception in GMT\n            \"fcnt\": 138,\t\t    // uplink FCNT (needed for decryption)\n            \"rssi\": -111,\t    \t// RSSI from gateway\n            \"snr\": -6,\t\t        // SNR from gateway\n            \"sf_used\": 8,\t        // used spreading factor – Depreciated,\n                                    // don’t use in new code.\n                                    // please use dr_used field instead.\n            \"dr_used\": \"SF8BW128\",\t// used data-rate, SF and BW\n            \"cr_used\":\"4/5\",        // Forward error correction code used\n            \"device_redundancy\":1,  // number of times the device has transmitted\n                                    // the burst\n            \"time_on_air_ms\":41.216,// Airtime for this burst [ms]\n            \"id\": 278998,\t        // unique identifier (64-bit) of payload.\n                                    // Needed to delete the payload\n            \"session_id\": \"0f9aaa82-b16c-4c2d-9b99-344e2f2c8b7d\",\t// session ID under which the packet was received\n            \"decrypted\": true,     // set true if the DASS decrypted the payload,\n                                    // false if the message is still encrypted.\n\n            \"gtw_info\": [\t\t    // see note below.\n                {gtw_id: \"0000000012340000\", rssi: -100, snr: 5 },\n                {gtw_id: \"0000000012350000\", rssi: -90, snr: 15 },\n                ...\n            ],\n\n            \"push_status\": [        // only available with push_status=true option.\n                { \"app\": \"app-id1\", \"app_uuid\": \"uuid-of-app1\", status: 200 }\n                { \"app\": \"app-id2\", \"app_uuid\": \"uuid-of-app2\", status: 404 }\n                ...\n            ],\n\n            \"decoded\": {            // only availble with associated payload decoder\n                // user defined object from payload decoder\n            }\n        },\n        ...\n    ]\n</code> The gtw_info field is only present for accounts that have the “can access network gateway info” right. It contains a list of all gateways that receive the uplink message, and the signal quality data associated with it. The gateway ID can be used to query the gateway location through the gateway API. The session_id field in the payload message is used to identify for which join session the message was received. When the application manages the decryption (i.e. the keys are not available on the DASS), the session_id can be used to check which appskey to use for the decryption. push_status is an array that show the status from push to an application. Currently status is only available for REST based push. Note: when query mac_msg=true is used, non-application payloads may be inserted in the list of payloads. These system payloads are from varies LoRaWAN control messages, and can be identified by the port value. All application payloads always have a port value &gt;= 1. Payloads that have been inserted by the system may have either no port value (null), or 0 or negative values. Return values: \n  \n    \n      Status value\n      Meaning\n      Description\n    \n  \n  \n    \n      200\n      OK\n      Request ok. The above list of payloads is return in the message body\n    \n    \n      204\n      No Payload\n      Request ok, but there is currently no payload pending for this device (i.e. the persistent temporary storage is empty).\n    \n    \n      401\n      Unauthorized\n      The username/password used in the basic authentication scheme is invalid or not present.\n    \n    \n      404\n      Unknown device\n      The DevEUI is not known\n    \n  \n Receive latest payload from device Devices where only the latest value is relevant can be query for just the latest received payload. <code>URL: https://host[:port]/rest/nodes/{deveui}/payloads/ul/latest Method: GET \\ Direction: Application-&gt;DASS\n</code> A JSON message body is returned with a single payload object (i.e. no array). The payload object is described in the previous section. Return values: \n  \n    \n      Status value\n      Meaning\n      Description\n    \n  \n  \n    \n      200\n      OK\n      Request ok. Single JSON object with payload and parameters (see @sec:getPayloadsUl).\n    \n    \n      204\n      No Payload\n      Request ok, but there is currently no payload pending for this devices (i.e. the persistent temporary storage is empty).\n    \n    \n      401\n      Unauthorized\n      The username/password used in the basic authentication scheme is invalid or not present.\n    \n    \n      404\n      Unknown device\n      The DevEUI is not known\n    \n  \n Delete Uplink Payload Payloads stay in OrbiWAN persistent temporary storage until they are deleted by the application or until the payload expiry period is reached. Once a payload has been read and provided to its destination(s) is should be deleted.\nThe payload is deleted based on its unique id that is provided to the application in the same message as the payload itself. <code>URL: https://host[:port]/rest/nodes/{deveui}/payloads/ul/{id} Method: DELETE \\ Direction: Application-&gt;DASS\n</code> Return value: \n  \n    \n      Status value\n      Meaning\n      Description\n    \n  \n  \n    \n      200\n      OK\n      Payload successfully deleted\n    \n    \n      401\n      Unauthorized\n      The username/password used in the basic authentication scheme is invalid or not present.\n    \n    \n      404\n      Unknown device\n      The DevEUI is not known\n    \n  \n Send Downlink Payload to Device or Multicast group Downlink payloads are sent to the DASS for it to transmit them to the device on next opportunity. Payloads are provided either encrypted or un-encrypted depending on the chosen key scheme (see 4.3.1). Note: Devices that does not use the default application payload scheme (option in upcoming LoraWAN specification) does not need to provide the FCNT, but must encrypt the payload in a self-containing way that does not rely on the MAC frame FCNT. This will be detailed further in a later release. <code>URL: https://host[:port]/rest/nodes/{deveui}/payloads/dl?port={xx}[&amp;fcnt={yy}][&amp;confirmed=true][&amp;mode=fail_on_busy|replace_on_busy|enqueue_on_busy][data_format=base64|hex]\n\nhttps://host[:port]/rest/multicast/{group-id}?port={xx}[&amp;fcnt={yy}]\n[&amp;mode=fail_on_busy|replace_on_busy|enqueue_on_busy][data_format=base64|hex]\n</code> Method: POST \nDirection: Application-&gt;DASS \n  \n    \n      Options\n      Description\n    \n  \n  \n    \n      port\n      LoRaWAN port number\n    \n    \n      fcnt\n      Optional LoRaWAN FCNT. Note when AppKey/AppSKey is know by the network this field is not needed, but when the application manage the payload encryption this field is mandatory.\n    \n    \n      confirmed\n      true/false (for unicast downlink only, not allowed on multicast)\n    \n    \n      mode\n      Determine the behavior when there are already messages pending in the downlink queue. See table below for the available values.\n    \n    \n      data_format\n      hex or base64\n    \n  \n The payload itself is put directly in the request message body in base64 format unless “data_format” is set to hex (&amp;data_format=hex) in which case message body must contain a valid hex payload. Downlink messages are by default transmitted as confirmed messages, but it is possible to control the usage of confirmed vs. unconfirmed downlink message types. Setting &amp;confirmed=false as a URL option will force transmission of the downlink as unconfirmed. If there is already an outstanding downlink message waiting to be sent, the default behavior is to en-queue the new message to be send after the outstanding package. However, it is often not relevant to have multiple outstanding packets if the downlink related to immediate status for class A devices. For this reason, it is possible to control the behavior of the downlink when there are already one or more outstanding downlinks. This can be controlled using the “mode” filter option on the URL. There are 3 modes: \n  \n    \n      mode\n      Description\n    \n  \n  \n    \n      fail_on_busy\n      Return error 409 if there is already one or more outstanding downlink waiting to be sent.\n    \n    \n      replace_on_busy\n      Abort any existing downlink messages (i.e. they will not be sent and will have cancelled state when querying their state) and schedule the new message for downlink.\n    \n    \n      enqueue_on_busy\n      Schedule the downlink to be sent after all already outstanding messages have been sent. The maximum number of outstanding downlinks is limited to 10 or the value set in the service / connectivity profile. An error (409) is return when the max number of outstanding downlinks have been reached.\n    \n  \n Note, while the default behavior is “enqueue_on_busy“ (backward compatibility reasons) it is recommended to use “fail_on_busy” or “replace_on_busy” whenever possible to avoid sending downlink that are already “out-of-date”. As it may take long time before the payload can be transmitted it is not possible to get delivery status on the payload immediately. Instead the DASS must query the packet status, and a unique ID is therefore assigned to the downlink payload and returned on the POST for the DASS to identify the payload for later query. The post returns the following JSON object: <code class=\"language-JSON\">    {\n        \"id\": 252,\t\t\t// unique ID to query payload later\n        \"data\": \"ABC=\",\t\t\t// *Optional the payload data sent)\n        \"fcnt\": 10,\t\t\t// the usedFCNT\n        \"port\": 1,\t\t\t// the used port\n        \"transmissionStatus\": 0\t// see definition below\n        \"session_id\": \"UUID\"\t\t// session ID when packet was created\n    }\n</code> \n  Has to be enabled in a configuration field, by default not included, used only for backwards compatibility.\n The meaning of the transmission status is the following: \n  \n    \n      Transmission status\n      Description\n    \n  \n  \n    \n      0\n      Payload pending transmission (i.e. not sent yet)\n    \n    \n      1\n      Payload has been sent, but reception status unknown\n    \n    \n      2\n      Payload has been sent and acknowledged by the device\n    \n    \n      3\n      Payload has been sent, and NOT acknowledged by the device =&gt; most likely the device did not receive the downlink payload.\n    \n    \n      4\n      An error has been discovered on the payload. The possible reasons for this error are: FCNT collision, payload size too big.\n    \n    \n      5\n      Payload has been cancelled. This happens if downlinks have been queued but are erased again due to new JOIN, or if the payloads have been purged.\n    \n  \n The downlink packet life cycle is shown in @fig:downlinkLifeCycle. The transmission status get updated live to reflect the status of the packet. If an application has registered for push, it will receive a downlink payload status callback message (see @sec:pushPayloadDl) on every change of the status. {#fig:downlinkLifeCycle} Note: It is import to wait for the POST to complete before making a new POST with another payload. Scheduling several payloads in parallel is not supported and can have unexpected results. Return values: \n  \n    \n      Status value\n      Meaning\n      Description\n    \n  \n  \n    \n      200\n      OK\n      Payload successfully scheduled for transmission, and message body will contain the above JSON object.\n    \n    \n      401\n      Unauthorized\n      The username/password used in the basic authentication scheme is invalid or not present.\n    \n    \n      404\n      Unknown device\n      The DevEUI is not known\n    \n    \n      409\n      Busy or Queue full\n      The downlink queue is full or not empty (in case of mode=fail_on_busy).\n    \n  \n Check Downlink Payload Status After scheduling a payload for transmission to a device, the status of the packets successful delivery to the device can be queried. The payload status is queried by the ID returned from the POST command (see @sec:postDownlink). <code>URL: https://host[:port]/rest/nodes/{deveui}/payloads/dl/{id}\nURL: https://host[:port]/rest/multicast/{groupid}/payloads/dl/{id}\n</code> Method: GET \nDirection: Application-&gt;DASS The command returns the same JSON object as that returned by the payload POST commands (see @sec:postDownlink). After the payload transmission has concluded (either successfully or not) the application should delete the payload packet from the DASS using the delete downlink payload command (see @sec:deletePayloadDl). If the application does not delete the payload it will be automatically delete when the expiry period has been reached. Return values: \n  \n    \n      Status value\n      Meaning\n      Description\n    \n  \n  \n    \n      200\n      OK\n      The downlink status and payload has been successfully found and returned in the message body. See @sec:postDownlink for the details on the JSON object.\n    \n    \n      401\n      Unauthorized\n      The username/password used in the basic authentication scheme is invalid or not present.\n    \n    \n      404\n      Unknown device and/or packet ID\n      The DevEUI is not known or the packet ID does not exist.\n    \n  \n Get Status for all Downlink Payloads Similarly to querying for a single downlink, it is also possible to get the entire list of payloads for both device and multicast. <code>URL: https://host[:port]/rest/nodes/{deveui}/payloads/dl[?query_options]\nURL: https://host[:port]/rest/multicast/{groupid}/payloads/dl[?query_options]\n</code> Method: GET \nDirection: Application-&gt;DASS Supported query options: \n  \n    \n      Parameter\n      values\n      description\n    \n  \n  \n    \n      data_format\n      hex,base64\n      Data format for all binary data. Default is base64\n    \n    \n      from_date\n      ISO8601 date/time\n      show only payload from after this time/date\n    \n    \n      to_date\n      ISO8601 date/time\n      show only payload from before time/date\n    \n    \n      get_pages\n      boolean\n      see section on paged queries\n    \n    \n      limit\n      number\n      see section on paged queries\n    \n    \n      page_state\n      string\n      see section on paged queries\n    \n    \n      paged_results\n      boolean\n      see section on paged queries\n    \n    \n      mac_msg\n      boolean\n      when true and user has rights to see MAC message, the returned list of payloads will include the raw LoRaWAN Mac frames. Default is false.\n    \n    \n      search_port\n      string\n      filter by port number. Port can be composed of comma separated ranges. E.g. “1-10,50-55,100,200-“ will return payloads with port values from 1 to 10 and 50 to 55, 100 and 200 to 255. When the range ‘-‘ is left open, e.g. 100- or -50 it means from 100 to 255 or from 0 to 50 respectively.\n    \n    \n      search_transmission_status\n      number\n      shown only payloads with particular transmission status.\n    \n    \n      sort_by_timestamp\n      asc,desc\n      Sort the payloads by the timestamp ascending or descending.\n    \n    \n      strict\n      boolean\n      enforce strict checking of all parameters\n    \n  \n The command will return an JSON array with the same status messages as described for the POST downlink command (see sec:postDownlink). E.g. <code class=\"language-JSON\">[{\n    \"id\": 252,\t\t\t// unique ID to query payload later\n    \"data\": \"ABC=\",\t\t\t// the payload data sent\n    \"fcnt\": 10,\t\t\t// the used fcnt\n    \"port\": 1,\t\t\t// the used port\n    \"transmissionStatus\": 1,\t// see definition below\n    \"session_id\": \"UUID\"\t\t// session ID when packet was created\n},{\n   \"id\": 254,\t\t\t// unique ID to query payload later\n    \"data\": \"ABC=\",\t\t\t// the payload data sent\n    \"fcnt\": 11,\t\t\t// the used fcnt\n    \"port\": 1,\t\t\t// the used port\n    \"transmissionStatus\": 0,\t// see definition below\n    \"session_id\": \"UUID\"\t\t// session ID when packet was created\n\t}, ... {\n    ...\n}]\n</code> Note: when query mac_msg=true is used, non-application payloads may be inserted in the list of payloads. These system payloads are from varies LoRaWAN control messages, and can be identified by the port value. All application payloads always have a port value &gt;= 1. Payloads that have been inserted by the system may have either no port value (null), or 0 or negative values. Return values: \n  \n    \n      Status value\n      Meaning\n      Description\n    \n  \n  \n    \n      200\n      OK\n      The downlink status and payload has been successfully found and returned in the message body. See @sec:postDownlink for the details on the JSON object.\n    \n    \n      401\n      Unauthorized\n      The username/password used in the basic authentication scheme is invalid or not present.\n    \n  \n Get Status for all Downlink Payloads <code>URL: https://host[:port]/rest/nodes/{deveui}/payloads/all[?query_options]\n</code> Method: GET \nDirection: Application-&gt;DASS This is a convenience query that can return both uplinks and downlink in the same query. It returns a list of mixed up and downlinks. All the combined query options from the https://host[:port]/rest/nodes/{deveui}/payloads/ul and https://host[:port]/rest/nodes/{deveui}/payloads/dl can be used with this query. And in addition the following queries are available. \n  \n    \n      Parameter\n      Values\n      Description\n    \n  \n  \n    \n      payload_type:\n      uplink,downlink\n      when present show only uplink or downlink. When omitted both are shown\n    \n  \n Return values: \n  \n    \n      Status value\n      Meaning\n      Description\n    \n  \n  \n    \n      200\n      OK\n      The downlink status and payload has been successfully found and returned in the message body.\n    \n    \n      401\n      Unauthorized\n      The username/password used in the basic authentication scheme is invalid or not present.\n    \n  \n Delete Downlink Payload Downlink payloads stay in the OrbiWAN temporary storage even after having been sent to allow the application to query the status of the payload transmission. When the application has seen the completion of the downlink the payload should be deleted using this command. <code>URL: https://host[:port]/rest/nodes/{deveui}/payloads/dl/{id} Method: DELETE \\ Direction: DASS-&gt;RNSS\n</code> Return value: \n  \n    \n      Status value\n      Meaning\n      Description\n    \n  \n  \n    \n      200\n      OK\n      The payload has been deleted.\n    \n    \n      401\n      Unauthorized\n      The username/password used in the basic authentication scheme is invalid or not present.\n    \n    \n      404\n      Unknown device and/or packet ID\n      The DevEUI is not known or the packet ID does not exist.\n    \n  \n","url":"rest.html","anchor":"payload-management--detailed-description"},{"objectID":"rest-api-sec:pushModeDescription","hierarchy_lvl0":"Documentation","hierarchy_lvl1":"REST API","hierarchy_lvl2":"Push Mode Callbacks – Detailed Description","content":" Push Mode Callbacks – Detailed Description Applications can subscribe to push-notifications. Push notification can be delivered through any of the following protocols: \n  REST\n  WebSocket\n  MQTT\n Applications can chose the protocol that is most suitable for the application. For additional convenience when using either WebSocket or MQTT it is also possible to send downlink message via either WebSocket and MQTT. There are nine types of push notification messages that are sent. Applications can decide to subscribe to only a subset of them. The eight notification are: \n  \n    \n      Notification\n      Description\n    \n  \n  \n    \n      payloads_ul_early\n      Uplink message received. The message body contains the uplink message data and port number. This notification is sent as early as possible to allow the application to be able to respond to the message and have it send back to the device on the immediate following downlink opportunity.\n    \n    \n      payloads_ul(complete)\n      Uplink message received. The message body contains the uplink message data and port number, and the RSSI and SNR of the best gateway that received the data. Further depending on the rights of the application, the message may also contain the full list of gateways that received the message and the estimated Geo location of the device. As this message requires aggregation of data from multiple gateways and optional processing of geo locations data, this message will arrive too late to be able to send data back to the device on the immediately following downlink opportunity.\n    \n    \n      payloads_dl\n      This notification is send with the status of a scheduled downlink. The notification will be send when the downlink have actually been sent, and in case of confirmed downlink, when the downlink have been (or not) acknowledged. If an error happened on the downlink this will also be indicated on this notification. This notification may be send several times as the state changes.\n    \n    \n      multicast\n      The multicast status is similar to the payloads_dl message, but is for multicast messages.\n    \n    \n      nodeinfo\n      A nodeinfo notification is sent tell the application that the state of a device has changed. This is the case when the network schedules a downlink without request from the application. In this case the downlink FCNT counter is incremented, and the nodeinfo notification is send to notify the application of this change.\n    \n    \n      status\n      The status notification is sent when the device have reported back the DevStatusAns which report the battery level of the device and the downlink link margin.\n    \n    \n      join\n      Raw LoraWAN join message sent to the application when the application want to manage directly the JOIN procedure and process the JOIN-REQ, JOIN-ACCEPT and session keys.\n    \n    \n      joininfo\n      Send when the a device have send a join request message and the network has accepted the device.\n    \n    \n      location\n      A location estimate has been updated for the device. Note, this message is redundant with the payloads_ul(complete) notification that will also include the location information when available.\n    \n    \n      alarm\n      An issue is detected and the DASS will notify the application about it with the alarm message.\n    \n  \n The application can subscribe to all the messages or select a subset. The default it to subscribe to all the message except the payloads_ul_early message. Note: an application can subscribe to both payloads_ul_early_ and payloads_ul(complete) messages. In this case the application will receive both messages and the application must take care not to confuse the two messages for different uplinks and process the data twice. The early message has a field early that is set to true to indicate that this message is of early type and that realtime downlink is possible. Note2: Subscription to payloads_ul_early messages is conditional on the service profile, and only service profiles that allow “real-time” downlink will be able to receive the payloads_ul_early notification. As the notification subscription is set per application and not per device, it is possible that there are devices that both support and not support the early message due to different service profiles. If the application subscribes only to the early notification and receive an uplink from a device with a service profile that doesn’t support it, the DASS will automatically send the complete type message instead for those devices. Receive Uplink Payload Callback When a new uplink payload arrives the RNSS will store the message in the persistent temporary storage. If the application has registered push-mode callback the DASS will then immediately send the payload to the application with a POST. When the application has finished the request (i.e. answered 200 OK) the RNSS will automatically delete the payload from the persistent temporary storage again. Note, the RNSS may delay the storage into the persistent temporary storage database by a configurable duration (e.g. 500ms) and if the application has confirmed the reception of the payload before this duration they payload will never be stored. This behavior is transparent to the USER. Push mode can be setup separately for each user and application. The DASS push the following message on the payload arrival: <code>URL: https://dass-host[:port][url-prefix]/rest/callback/payloads/ul\nURL: https://dass-host[:port][url-prefix]/rest/callback/payloads/ul_early\n</code> Method: POST \nDirection: DASS-&gt;Application The message body contain the following JSON object. For the payloads_ul(complete) type message the following JSON is received: <code class=\"language-JSON\">    {\n        \"early\": false,         // true: payloads_ul(early), false: payloads_ul(complete)\n        \"deveui\": \"hex\",        // DevEUI of source device\n        \"dataFrame\": \"AB==\",    // raw (encrypted) payload in base64 format\n        \"port\": 1,              // MAC port the message was receive on\n        \"timestamp\": \"2015-02-11T10:33:00.578Z\",    // time of reception in GMT\n        \"fcnt\": 138,            // uplink FCNT (needed for decryption)\n        \"rssi\": -111,           // RSSI from gateway\n        \"snr\": -6,              // SNR from gateway\n        \"sf_used\": 8,           // used spreading factor\n        \"id\": 278998,           // unique identifier (64-bit) of payload.\n        \"live\": true,           // indicate if the message is live, or\n                                // resent from the temporary storage\n        \"session_id\": \"session-uuid\", // session ID under which the packet was received\n        \"decrypted\": false      // set true if the DASS decrypted the payload,\n                                //  false if the message is still encrypted.\n\n        \"gtw_info\": [        // see note below.\n            {\"gtw_id\": \"0000000012340000\", \"rssi\": -100, \"snr\": 5 },\n            {\"gtw_id\": \"0000000012350000\", \"rssi\": -90, \"snr\": 15 },\n            ...\n        ],\n\n        \"latitude\": 34,\n        \"longitude\": 30,\n        \"altitude\": 0\n    }\n</code> When the application subscribes to the early type message, the following JSON is provided: <code class=\"language-JSON\">    {\n        \"early\": true,         // indicate if message is early or complete type\n        \"deveui\": \"hex\",        // DevEUI of source device\n        \"dataFrame\": \"AB==\",    // raw (encrypted) payload in base64 format\n        \"port\": 1,              // MAC port the message was receive on\n        \"timestamp\": \"2015-02-11T10:33:00.578Z\",    // time of reception in GMT\n        \"fcnt\": 138,            // uplink FCNT (needed for decryption)\n        \"sf_used\": 8,           // used spreading factor\n        \"id\": 278998,           // unique identifier (64-bit) of payload.\n        \"live\": true,           // indicate if the message is live, or\n                                // resent from the temporary storage\n        \"session_id\": \"session-uuid\", // session ID under which the packet was received\n        \"decrypted\": false      // set true if the DASS decrypted the payload,\n                                //  false if the message is still encrypted.\n    }\n</code> The gtw_info field is only present for accounts that have the “can access network gateway info” right. It contains a list of all gateways that receive the uplink message, and the signal quality data associated with it. The gateway ID can be used to query the gateway location through the gateway API. The application must acknowledge the POST request by returning on of the following return values: \n  \n    \n      Status value\n      Meaning\n      Description\n    \n  \n  \n    \n      200\n      OK\n      The application has taken the payload and the DASS can delete it from the persistent temporary storage\n    \n    \n      202\n      Accepted\n      The application received the payload but will not process it. The DASS must leave the payload in the persistent temporary storage so it can be read out later via the “pull” interface using the GET.\n    \n    \n      Any other value\n      ERROR\n      The DASS will keep the payload in the persistent storage.\n    \n  \n The behavior on any error is tbd. Current implementation ignores error and will not retry but will continue to push new messages. Error behavior will be detailed in later release. Downlink Payload Status Callback When a downlink payload transmission has completed (successfully or unsuccessfully) the DASS inform the application (if the application has registered for push mode) with message with the downlink delivery status. <code>URL: https://application-host[:port][url-prefix]/rest/callback/payloads/dl Method: PUT \\ Direction: DASS-&gt;Application\n</code> The message body contains the following JSON object: <code class=\"language-JSON\">    {\n        \"deveui\": \"hex\",            // DevEUI of the receiving device\n        \"id\": 252,                  // unique ID of the dl payload\n        \"data\": \"ABC=\",             // Optional*,the payload data sent\n        \"fcnt\": 10,                 // the used downlink FCNT\n        \"port\": 1,                  // the used port\n        \"tag\": \"optional-tag-string\",\n        \"transmissionStatus\": 0,\n        \"session_id\": \"UUID\"       // session ID when packet was created\n    }\n</code> The status of the downlink payload can be read in the transmissionStatus field, see table in @sec:postDownlink for a definition of the status values. The application must acknowledge the PUT request by returning on of the following return values: \n  \n    \n      Status value\n      Meaning\n      Description\n    \n  \n  \n    \n      200\n      OK\n      The application has read the downlink payload status\n    \n  \n Downlink Multicast Status Callback When a multicast payload transmission has completed (successfully or unsuccessfully) the DASS inform the application (if the application has registered for push mode) with message with the downlink delivery status. <code>URL: https://application-host[:port][url-prefix]/rest/callback/multicast Method: PUT \\ Direction: DASS-&gt;Application\n</code> The message body contains the following JSON object: <code class=\"language-JSON\">    {\n        \"groupid\": \"mulitcast-group-name\",\n        \"id\": 252,            // unique ID of the dl payload\n        \"fcnt\": 10,            // the used downlink FCNT\n        \"port\": 1,            // the used port\n        \"tag\": \"optional-tag-string\",\n        \"transmissionStatus\": 0,\n    }\n</code> The status of the multicast payload can be read in the transmissionStatus field, see table in @sec:postDownlink for a definition of the status values. The application must acknowledge the PUT request by returning on of the following return values: \n  \n    \n      Status value\n      Meaning\n      Description\n    \n  \n  \n    \n      200\n      OK\n      The application has read the downlink payload status\n    \n  \n Device Info Update Callback{#sec:pushNodeinfo} When device info is updated (e.g. the downlink FCNT is changed) and the application has registered for push message, the DASS will send a message with the device information to the application. <code>URL: https://application-host[:port][url-prefix]/rest/callback/nodeinfo Method: PUT \\ Direction: DASS-&gt;Application\n</code> The message contains the following JSON object: <code class=\"language-JSON\">{\n    \"deveui\": \"hex\",               // DevEUI of source device\n    \"device_status\": 3,\n    \"last_reception\": \"timestamp\", // time when device was last seen in GMT time\n    \"dl_fcnt\": 45,                 // last used downlink FCNT\n    \"device_class\": 0,             // 0: class A, 1: class B, 2: class C\n    \"registration_status\": 1,\n    \"expiry_time_uplink\": 168,     // ul payload expiry time in hours\n    \"expiry_time_downlink\": 168    // dl payload expiry time in hours\n}\n</code> See @sec:getDevice for definition of device_status and registration_status values.\nThe application must acknowledge the PUT request by returning on of the following return values: \n  \n    \n      Status value\n      Meaning\n      Description\n    \n  \n  \n    \n      200\n      OK\n      The info was received by the DASS\n    \n    \n      Any other value\n      ERROR\n      The behavior on any error is tbd. Current implementation ignores error and will not retry but will continue to push new messages. Error behavior will be detailed in later release.\n    \n  \n Device Status Update Callback When the device status from a device has been received by OrbiWAN and an application has registered for push mode, the DASS send a push notification with the device status update to the application. <code>URL: https://application-host[:port][url-prefix]/rest/callback/status Method: PUT &lt;bt&gt; Direction: DASS-&gt;Application\n</code> The message body contains the following JSON object: <code class=\"language-JSON\">    {\n        \"deveui\": \"hex\",    // DevEUI of source device\n        \"battery_status\": 0,    // value from LoraWAN specification,\n                    // 0: connected to power source,\n                    // 1..254: battery level 1 being minimum and\n                    // 254 being maximum,\n                    // 255: not possible for the device to measure\n                    // battery level\n        \"margin_status\": 0,    // demodulation SNR [dB]for the DevStatusReq\n                            // command message received\n        \"timestamp_status\": \"2015-02-06T10:43:23.331Z\", // UTC time last report\n        \"req_status\": 2        // 0: never updated, 1: update requested,\n                            // 2: request pending, 3: result ready\n    }\n</code> The application must acknowledge the PUT request by returning on of the following return values: \n  \n    \n      Status value\n      Meaning\n      Description\n    \n  \n  \n    \n      200\n      OK\n      The info was received by the DASS\n    \n    \n      Any other value\n      ERROR\n      The behavior on any error is tbd. Current implementation ignores error and will not retry but will continue to push new messages. Error behavior will be detailed in later release.\n    \n  \n Join Callback When a device is registering on OrbiWAN using the JOIN procedure and the AppKey is NOT provided to the DASS, the DASS will forward the JOIN request to the application for it to authenticate, generate keys and encrypt the join accept message. Note, there is no pull mode version of the join callback, hence push modem must be enabled at all times for join procedure device to be able to join the network, unless the AppKey has been registered on the DASS in which case the internal Join Server will manage the JOIN procedure autonomously. The join procedure has real-time constraints and the application must answer back to the DASS within &lt; 3 seconds. <code>URL: https://application-host[:port][url-prefix]/rest/callback/join Method: PUT \\ Direction: DASS-&gt;Application\n</code> The message body contains the following JSON object: <code class=\"language-JSON\">{\n    \"deveui\": \"hex\",            // DevEUI (8 bytes) of source device\n    \"appeui\": \"hex\",            // AppEUI (8 bytes) of source device\n    \"join_request\": \"base64\",   // raw join request message from device\n    \"join_accept\": \"base64\",    // unencrypted join accept message to\n                                // be encrypted\n    \"session_id\": \"uuid\"        // integer session ID\n}\n</code> The application (or DASS) must perform the MIC check on the raw join request message using the AppKey. If the MIC is valid the application can extract the DevNonce from the join request message, the AppNonce, NetID and DevAddr from the unencrypted join accept message and use these values together with the AppKey to create the two session keys, NwkSKey and AppSKey. The AppKey is then used to calculate the MIC of the join accept message and finally used to encrypt the join accept message. The details of join request and join accept frame formats are specified in [1] section 6.2.3 “Join procedure”. The session_id returned must be stored and associated with the generated AppSKey. After the JOIN sub-sequent uplinks received will be tagged with this session_id and the application knows that is must use the new AppSKey to decode the messages. There are circumstances where the join fails (related to varies security attach methods) and the old session is kept. In this case the application will see that sub-sequent uplink payloads received will continue to use the previous session_id. In this case the application should use the previous appskey for the message decoding. The encoded join accept message and the generated Network session key (NwkSKey) is then passed back to the OrbiWAN in the message body of the answer to the request. The answer JSON object is as follows: <code class=\"language-JSON\">{\n    \"deveui\": \"hex\",        // DevEUI (8 bytes) of source device\n    \"join_accept\": \"base64\",     // encrypted join accept message to send\n                    // back to the joining device\n    \"nwkskey\": \"hex\"           // Generate network session key (16-bytes)\n}\n</code> Return values: \n  \n    \n      Status value\n      Meaning\n      Description\n    \n  \n  \n    \n      200\n      OK\n      The join request MIC is ok and a valid join accept message and nwkskey is available in the JSON message body.\n    \n    \n      403\n      Forbidden\n      The DevEUI is not known and this device is not allowed to join\n    \n    \n      406\n      Not acceptable\n      The DevEUI is known, but the MIC check failed.\n    \n  \n Join-Info Callback When a device is joining the network and the JOIN procedure is managed either by the internal join server or by external JOIN server, the DASS will send a number of Join-Info message to the application to inform the application that the device has send a JOIN REQ message, and whether the device has been accepted on the network. Further a second message will be sent by the DASS if and when the device has cleared the three-phase join phase by having send a valid uplink message using the new keys from the JOIN procedure. <code>URL: https://application-host[:port][url-prefix]/rest/callback/joininfo Method: PUT \\ Direction: DASS-&gt;Application\n</code> The message body contains the following JSON object: <code class=\"language-JSON\">{\n    \"deveui\": \"hex\",    // DevEUI (8 bytes) of source device\n    \"appeui\": \"hex\",    // AppEUI (8 bytes) of source device\n    \"join_status\": \"JOIN_ACCEPTED\",\n    \"session_id\": \"uuid\"\n}\n</code> The join_status field can have the following values: | Join_status          | Description                                                                                                                                                                  |\n| ——————– | —————————————————————————————————————————————————————————- |\n| JOIN_FAILURE_BAD_MIC | A JOIN request was received from a device with the DevEUI but failed the authentication check (i.e. the MIC value is wrong)                                                  |\n| JOIN_ACCEPTED        | A JOIN request was received and the MIC is ok, and the network has sent back a JOIN_ACCEPT message to the device                                                             |\n| JOIN_FAILURE_BAD_MIC | A join request was received from a device with the deveui but failed the authentication check (i.e. the MIC value is wrong)                                                  |\n| JOIN_NOT_PROCESSED   | The DASS was not able find a source for the Appkey. This can happen if a Join server is used and is not available at the time of the JOIN.                                   |\n| JOIN_COMPLETE        | The device completes the JOIN ACCEPT procedure and has successfully send an uplink to the network using the new key                                                          |\n| JOIN_ABORTED         | The status is sent if the device after sending a JOIN continued to transmit using it “old” NwkSKey that was used before the JOIN (if the device was active before the JOIN). |\nThis can happen if a device tried to send a re-JOIN message but did not receive the JOIN ACCEPT and then continue to transmit data with the old key. Another reason for this message can also be that a JOIN replay-attach is being perpetrated on the network. The application should respond with the following return value: \n  \n    \n      Status value\n      Meaning\n      Description\n    \n  \n  \n    \n      200\n      OK\n      The status was received\n    \n  \n Geo-Location Info Callback When a device has Lora Geo-Location enabled, the location solver will make location estimates for the devices on the received uplinks. Not every uplink will result in a new location estimate. When a new estimate is available, the network push the new location estimate to the application. <code>URL: https://application-host[:port][url-prefix]/rest/callback/location Method: PUT \\ Direction: DASS-&gt;Application\n</code> The message body contains the following JSON object: <code class=\"language-JSON\">{\n    \"deveui\": \"hex\",              // DevEUI (8 bytes) of source device\n    \"latitude\": 46.207390,\n    \"longitude\": 6.155835,\n    \"loraloc_time\": \"timestamp\",  // timestamp of location estimate\n    \"loraloc_fcnt\": 123           // FCNT of last uplink used in\n                                  // lora location estimate\n\n}\n</code> The application should respond with the following return value: \n  \n    \n      Status value\n      Meaning\n      Description\n    \n  \n  \n    \n      200\n      OK\n      The status was received\n    \n  \n Alarm Callback When an issue is detected, the DASS will push an alarm message. The alarm message contains an alarm_type that gives information about the kind of issue. Also a severity field (in accordance with the syslog severity) is also present to indicate if the alarm is an error, warning, info, etc. <code>URL: https://application-host[:port][url-prefix]/rest/callback/alarm Method: POST \\ Direction: DASS-&gt;Application\n</code> The message body contains the following JSON object: <code class=\"language-JSON\">{\n    \"timestamp\": \"ISO8601\",             // time of the alarm\n    \"severity\": \"warning\",              // see table below\n    \"category\": \"devices\",        // see table below\n    \"alarm_code\": \"UPLINK_WITHOUT_ADR\", // see table below\n    \"deveui\": \"hex\",            // when applicable\n    \"gtw_id\": \"hex\",            // when applicable\n    \"userid\": \"userid\",          // when applicable\n    \"alarm_text\": \"textual description of alarm\"    // when applicable\n}\n</code> The severity can have the following values: \n  \n    \n      Severity\n      Description\n    \n  \n  \n    \n      alert\n      Action should be taken immediately\n    \n    \n      critical\n      Critical conditions\tHard device errors.\n    \n    \n      error\n      Error conditions\n    \n    \n      warning\n      Warning conditions\n    \n    \n      notice\n      Conditions that are not error conditions, but that may require special handling.\n    \n    \n      info\n      Informational messages\n    \n    \n      debug\n      Messages that contain information normally of use only when debugging a program.\n    \n  \n The category can have the following values: \n  \n    \n      Category\n      Description\n    \n  \n  \n    \n      devices\n      the alarm is related to a device. The deveui of the device is always available in the message\n    \n    \n      gateways\n      the alarm is related to a gateway. The gateway ID is always available in the message\n    \n    \n      applications\n      the alarm is related to the application associated to the account\n    \n    \n      accounts\n      the alarm is related to the owning account.\n    \n    \n      system\n      for administrator only\n    \n  \n The alarm_code can have the following values: \n  \n    \n      Alarm code\n      Category\n      Description\n    \n  \n  \n    \n      UPLINK_WITHOUT_ADR\n      devices\n      An uplink message was received without the ADR bit set and the device’s connectivity profile does has the allow_non_adr = false. In this case the uplink is not forwarded to the application, nor is it stored. Only this message is sent. For the device to work normally, a service profile having a connectivity profile with allow_non_adr set must be assigned to the device. The deveui of the device is present in the message.\n    \n  \n The application should respond with the following return value: \n  \n    \n      Status value\n      Meaning\n      Description\n    \n  \n  \n    \n      200\n      OK\n      The alarm was received\n    \n  \n Push Mode Start When an application wants to receive push messages from the DASS it must first implement a HTTPS host interface that can be reached from the DASS and identified by a hostname or IP address. The application can then register the interface on the DASS and start push mode, which will cause the DASS to push any new payload or update in status directly to the application host interface. The application must implement the paths specified in previous sections for each of the different types of push messages. To register and start the push mode service the following message is used: <code>URL: https://dass-host[:port] /rest/pushmode/start\nURL: https://dass-host[:port] /rest/pushmode/start/{application-id} Method: PUT \\ Direction: application-&gt;DASS \\ Optional queries: strict=[true,false], update_only=[true,false]\n</code> Note, applications accounts can only call /rest/pushmode/start. An account can start push from the account itself or directly start push for one of its application sub-accounts via /rest/pushmode/start/{application-id}. The application sub-account must exist before calling start, it is not created by this call. The message body must contain a JSON object with the following parameters: <code class=\"language-JSON\">{\n    \"host\": \"hostname\",      // Hostname or IP address\n                             // of DASS HTTPS host interface\n    \"port\": 1234,            // port number of DASS HTTPS host interface\n    \"path_prefix\": \"/abc\",   // path prefix\n\n    \"auth_string\": \"string\", // see below\n    \"push_auth_access_token\": \"authentication-token\",   // for Bearer HTTP authentication\n    \"push_auth_username\": \"username\",\n    \"push_auth_password\": \"password\",\n\n    \"push_auth_cert\": \"certificate-pem\",\n    \"push_auth_key\": \"private-key-pem\",\n    \"push_auth_passphrase\": \"pem-passphrase\",\n\n    \"retry_policy\": 0,       // for future use, must be set to zero\n    \"data_format\": \"hex\",    // hex, base64 or decoded_json. Default is base64.\n    \"push_subscription\": \"payloads_ul,payloads_dl,nodeinfo,alarm\"\n}\n</code> The host name must be prefixed by “http://” or “https://” for REST style push, or “mqtt://” or “mqtts://” for connection MQTT broker. The DASS will use the auth_string directly as the argument of the “Authorization” http header tag. I.e. the auth_string must contain the complete argument (e.g. “Basic base64”). The auth_string is mutually exclusive with push_auth_access_token and push_auth_username/push_auth_password. Only on of the three types of authentication can be specified at any given time. The DASS will push messages to the host and port specified in the JSON object. The path_prefix is added in front of the /rest/… path allowing the application host interface to be implemented in a sub-path on a shared host. The push_subscription is a comma separated string with the list of types of push notification the application want to receive. The available types are: \n  payloads_ul_early\n  payloads_ul\n  payloads_dl\n  multicast\n  status\n  location\n  nodeinfo\n  joininfo\n  join\n  alarm\n Each of the above type correspond to the notification types described in the table at the beginning of this chapter. It is possible to only update the push server information without starting the push. Setting the ?update_only=true query will update settings but will not change the current state (i.e. start or stop) the push mode. The DASS will return one of the following values: \n  \n    \n      Status value\n      Meaning\n      Description\n    \n  \n  \n    \n      200\n      OK\n      The push mode registration was successful. Push mode is now started.\n    \n    \n      401\n      Unauthorized\n      The username/password used in the basic authentication scheme is invalid or not present.\n    \n    \n      400\n      Bad request\n      The JSON object is not valid\n    \n  \n Push Mode Stop When the application no longer can receive push messages (e.g. if the application is stopped or restarted) it should deregister from the DASS and the DASS will stop sending push message. <code>URL: https://dass-host[:port] /rest/pushmode/stop[/{application-id}] Method: PUT \\ Direction: application-&gt;DASS\n</code> \n  \n    \n      Status value\n      Meaning\n      Description\n    \n  \n  \n    \n      200\n      OK\n      Push mode is stopped\n    \n    \n      401\n      Unauthorized\n      The username/password used in the basic authentication scheme is invalid or not present.\n    \n  \n Push Mode Status To check the status of the current settings of pushmode, <code>URL: https://dass-host[:port] /rest/pushmode/status[/{application-id}] Method: GET \\ Direction: application-&gt;DASS\n</code> The following object is returned. <code class=\"language-JSON\">{\n    \"enabled\": true,\n    \"host\": \"https://lora.orbiwise.com\",\n    \"port\": 443,\n    \"path_prefix\": \"/v1/networks/ubiq/uplink\",\n\n    \"auth_string\": \"\",                                  // optional\n    \"push_auth_access_token\": \"authentication-token\",   // for Bearer HTTP authentication\n    \"push_auth_cert\": \"certificate-pem\",\n    \"push_auth_key\": \"private-key-pem\",\n    \"push_auth_passphrase\": \"pem-passphrase\",\n\n    \"retry_policy\": 0,\n    \"data_format\": \"base64\",\n    \"push_subscription\": \"payloads_ul,payloads_dl,nodeinfo\"\n}\n</code> Push Mode Connections Get list of connections to current user. <code>URL: https://dass-host[:port] /rest/pushmode/connections\nURL: https://dass-host[:port] /rest/pushmode/connections/{application-id} Method: GET \\ Direction: application-&gt;DASS\n</code> This API returns the list of connections and subscriptions for both WebSocket and MQTT as well as enabled push notification via http/https to a URL. The fields in the returned object depends on the connection type. When the API is called from an account, all connections from all application sub-accounts and the account itself are returned. If the API is called by an application, only the connections for that application is returned. The following object is returned: <code class=\"language-JSON\">[\n    {\n        \"type\": \"websocket\",\n        \"appid\": \"app-id\",   // application sub-account ID, if not present the user account itself.\n        \"status\": \"\",        // for brkoer clients only\n        \"connection_time\": \"ISO8601-timestamp\", // time of connection (websocket or mqtt only)\n        \"subscription\": \"payloads_ul,payloads_dl,nodeinfo\", // see section on subscription\n        \"remote_address\": \"ip-address\",         // remote IP address for websocket and MQTT host-mode connections\n        \"url\": \"https:/xx.com\",                  // for url http/https push only\n        \"error\": \"error-message\"\n    },\n    ...\n]\n</code> The connection type can be one of the following: \n  \n    \n      type\n      Description\n    \n  \n  \n    \n      websocket\n      A connection from an external application is made via websocket\n    \n    \n      mqtt\n      A connection from an external application is made via MQTT (host-mode MQTT, see @sec:mqttHostMode)\n    \n    \n      url\n      Rest push mode is enabled for\n    \n    \n      mqtt-client\n      Push via MQTT to external broker is enabled (client-mode MQTT, see @sec:mqttClientMode).\n    \n    \n      kafka-client\n      Push via KAFKA to external broker is enabled.\n    \n  \n appid is the name of the application sub-account, if not present it means the connection is directly on the user account. status can be one of “connecting”, “connected” or “error”. When “connected” it means that a working connectiong between the DASS and the broker is establised. The status is only available for some connection types. Note: more fields may be returned for each connection but only the above specified fields should be used by any application as other fields may change and disappear without warning. \n  \n    \n      Status value\n      Meaning\n      Description\n    \n  \n  \n    \n      200\n      OK\n      result is returned as JSON object\n    \n    \n      401\n      Unauthorized\n      The username/password used in the basic authentication scheme is invalid or not present.\n    \n  \n Push Mode Log Get log <code>URL: https://dass-host[:port] /rest/pushmode/log\n</code> Method: GET \nDirection: application-&gt;DASS The content has the following format: <code class=\"language-JSON\">[\n    {\n        \"evt\": \"ErrorWebSocketConnect\",\n        \"ts\": \"2019-05-30T14:08:41.611Z\",\n        \"txt\": \"\"\n    },\n    ...\n    {\n        \"evt\": \"ErrorPush\",\n        \"ts\": \"2019-05-30T14:08:41.611Z\",\n        \"deveui\": \"1234567812345678\",\n        \"app\": \"my-app\",\n        \"txt\": \"\"\n    }\n]\n</code> The evt field contains the log entry type, the ts is the timestamp of when the log was recorded, and the txt is a text field with additional information about the entry. Where relevant the application sub-account id is provided in the app field, and when the message is relevant to one particular device, the deveui is set to the device DevEUI value. \n  \n    \n      Status value\n      Meaning\n      Description\n    \n  \n  \n    \n      200\n      OK\n      result is returned as JSON object\n    \n    \n      401\n      Unauthorized\n      The username/password used in the basic authentication scheme is invalid or not present.\n    \n  \n Set Push Mode Log Level Get list of connections to current user. <code>URL: https://dass-host[:port] /rest/pushmode/loglevel?log_level=info&amp;duration_in_hours=24\n</code> Method: PUT \nDirection: application-&gt;DASS Possible values for log_level are: \n  \n    \n      value\n      Description\n    \n  \n  \n    \n      error\n      log only errors and rare events. (default)\n    \n    \n      info\n      log all push messages\n    \n  \n When a log level above error is set, it will only remain set for a duration of time, after which it will automatically go back to the error level. NOTE only messages pushed via HTTP/HTTPS push mode are logged. Messaged pushed via WebSocket and MQTT are currently not logged, however the connection and disconnection events to both WebSocket and MQTT are logged (at all log levels). Default interval if not specified is 24 hours. Setting duration_in_hours on the query can allow to set the duration up to one week. Longer periods are not allowed (except for users with SysAdmin rights that can set any duration). \n  \n    \n      Status value\n      Meaning\n      Description\n    \n  \n  \n    \n      200\n      OK\n      result is returned as JSON object\n    \n    \n      401\n      Unauthorized\n      The username/password used in the basic authentication scheme is invalid or not present.\n    \n  \n Get Push Mode Log Level Get list of connections to current user. <code>URL: https://dass-host[:port] /rest/pushmode/loglevel?log_level=info\n</code> Method: GET \nDirection: application-&gt;DASS <code class=\"language-JSON\">{\n  \"log_level\": \"info\",\n  \"until\": \"2019-09-11T11:50:38.862Z\"\n}\n</code> The default level is “error” that will log only errors and rare events. The the until field above is only shown for elevated logging (i.e. info) and show the time until the logging level will automatically be set back to error level. \n  \n    \n      Status value\n      Meaning\n      Description\n    \n  \n  \n    \n      200\n      OK\n      result is returned as JSON object\n    \n    \n      401\n      Unauthorized\n      The username/password used in the basic authentication scheme is invalid or not present.\n    \n  \n Repush an uplink payload [DMM] If some received payloads have not been successfully delivered to one or more applications, typically due to connection problem between application and DASS, the payload can be “pushed” again. <code>URL: https://dass-host[:port] /rest/pushmode/test/payload_ul/{deveui}/{payloadid}[?failed_only=true]\n</code> Method: POST \nDirection: application-&gt;DASS This API takes no payload. If called without *failed_only” query option, the DASS will push the payload to all enabled push applications accounts, regardless if data was already received and acknowledged. This is mainly intended to testing that connection to an application server is working. When called with failed_only=true query option, the DASS will not push to applications that have already acknowledged reception. The API returns with a list of status codes from each push target (when pushing with REST). If push to an application server that was previously marked as failed, but now succeed, the status of the payload for this application will be updated and will not be pushed again, if this api as called again with failed_only=true To see status of delivery of a payloads, see @sec:getPayloadsUl \n  \n    \n      Status value\n      Meaning\n      Description\n    \n  \n  \n    \n      200\n      OK\n      result is returned as JSON object\n    \n    \n      401\n      Unauthorized\n      The username/password used in the basic authentication scheme is invalid or not present.\n    \n  \n","url":"rest.html","anchor":"sec:pushModeDescription"},{"objectID":"rest-api-push-mode--push-via-web-socket","hierarchy_lvl0":"Documentation","hierarchy_lvl1":"REST API","hierarchy_lvl2":"Push-Mode – Push via Web Socket","content":" Push-Mode – Push via Web Socket The REST based on callback push mode described in the previous sections require that the application that registers for push has a public IP address can be accessed by the DASS. For applications running behind NAT or firewall this may not be possible. To support push-mode for applications with these constraints a second push-mode, push via WebSocket, is available. A WebSocket (RFC6455) is standard Internet protocol that is used between web-browsers and the web-servers to establish a bi-directional link to exchange data. As it is very commonly used in “normal” Internet web pages chances are good that varies firewall and corporate access policies will allow access of this kind. A web socket is established from the application with a connection to the server. The connection is setup with standard WebSocket header (which is basically HTTP). As for all request to the DASS, the basic authentication scheme is used, and the “Authorization” header field must be provided as described in @sec:pushModeDescription. Once the connection has been setup, the connection will remain open until the application closes the connection again. It is up to the application to re-establish the connection if the connection fails. Web sockets are message base meaning that the receiver side always receives a block of data at the same size as it was sent (unlike stream-based connections like TCP message boundaries are not guaranteed). Push via web socket is setup per user (as for Push with REST callback) but unlike the latter it is possible to have more than one web socket push connection per user. Applications can also send downlink (and multicast) via the websocket. Setup Web Socket Connection The application establishes the connection using a standard web socket connector. URL: wss://dass-host[:port] /websocket/connect [?push_subscription=payloads_ul,payloads_dl] Once established successfully the DASS will start to push messages the application. Each message is contained in JSON object. The ?push_subscription= URL query argument can be used to specify which messages the application wish to received. Please see sections @sec:pushModeStart for available topics to subscribe to. The following messages are used. Please refer to the listed sections for the details of the message and for the details for the inner JSON message body. \n  \n    \n      JSON body\n      Comment\n    \n  \n  \n    \n      { \"payloads_ul_early\": {...} }\n      see @sec:pushPayloadUl\n    \n    \n      { \"payloads_ul\": {...} }\n      see @sec:pushPayloadUl\n    \n    \n      { \"payloads_dl\": {...} }\n      see @sec:pushPayloadDl\n    \n    \n      { \"multicast\": {...} }\n      see @sec:pushMulticast\n    \n    \n      { \"nodeinfo\": {...} }\n      see @sec:pushNodeinfo\n    \n    \n      { \"status\": {...} }\n      see @sec:pushStatus\n    \n    \n      { \"join\": {...} }\n      see @sec:pushJoin\n    \n    \n      { \"joininfo\": {...} }\n      see @sec:pushJoinInfo\n    \n    \n      { \"location\": {...} }\n      see @sec:pushLocation\n    \n    \n      { \"alarm\": {...} }\n      see @sec:pushAlarm\n    \n  \n Downlink via Web Socket An application can also send a downlink via the web socket. <code class=\"language-JSON\">    {\n        \"payloads_dl\": {\n            \"confirmed\": true,\n            \"deveui\": \"aabbccdd00000000\",\n            \"data\": \"aabbcc\",\n            \"port\": 10,\n            \"data_format\": \"base64\" | \"hex\",        // optional, default to base64\n            \"fcnt\": 12,                             // optional\n            \"mode\": \"fail_on_busy\",                 // optional, default to enqueue_on_busy\n            \"session_id\": \"uuid-of-session\",        // optional,\n            \"tag\": \"request-tag\"                  // optional\n        }\n    }\n</code> The tag field can be filled by the application with a identifier for that the request that allow the application to associate response to this request. The DASS will include this tag on all message related to this downlink message. Upon reception of the message the DASS will, if there is no error in the message, immediately send back on the same WebSocket the following reply: <code class=\"language-JSON\">    {\n        \"payloads_dl\": {\n            \"deveui\": \"hex\",            // DevEUI of the receiving device\n            \"id\": 252,                  // unique ID of the dl payload\n            \"fcnt\": 10,                 // the used downlink FCNT\n            \"port\": 1,                  // the used port\n            \"transmissionStatus\": 0,\n            \"session_id\": \"UUID\",       // session ID when packet was created for OTAA devices\n            \"tag\": \"request-tag\"\n        }\n    }\n</code> See @sec:postDownlink for the values of transmissionStatus In the event of an error, the DASS will send back the following error object: <code class=\"language-JSON\">    {\n        \"error\": {\n            \"tag\": \"request-tag\",           // reference to requesting message\n            \"error_msg\": \"error message\",\n            \"status_code\": 404              // REST style status code, e.g. 404 not found\n        }\n    }\n</code> Send multicast message via WebSocket An application can send multicast message via WebSocket, by sending the following JSON message on the WebSocket. <code class=\"language-JSON\">    {\n        \"multicast\": {\n            \"groupid\": \"group-id\",\n            \"data\": \"aabbcc\",\n            \"port\": 10,\n            \"data_format\": \"base64\" | \"hex\",        // optional, default to base64\n            \"fcnt\": 12,                             // optional\n            \"mode\": \"fail_on_busy\",                 // optional, default to enqueue_on_busy\n            \"tag\": \"free-text-tag\"                  // optional\n        }\n    }\n</code> <code class=\"language-JSON\">    {\n        \"multicast\": {\n            \"groupid\": \"group-id\",      // multicast group id\n            \"id\": 252,                  // unique ID of the dl payload\n            \"fcnt\": 10,                 // the used downlink FCNT\n            \"port\": 1,                  // the used port\n            \"transmissionStatus\": 0,\n            \"session_id\": \"UUID\",       // session ID when packet was created\n            \"tag\": \"request-tag\"\n        }\n    }\n</code> The transmissionStatus (see @sec:postDownlink for definition of the status values) is set to zero indicating that the payload have been enqueued. Note this message is only send back on MQTT and not pushed in general (i.e. applications listening for REST or Web-Socket will not receive this message). In the even of an error, the following error object is sent: topic: username/multicast <code class=\"language-JSON\">    {\n        \"error\": {\n            \"tag\": \"request-tag\",           // reference to requesting message\n            \"error_msg\": \"error message\",\n            \"status_code\": 404              // REST style status code, e.g. 404 not found\n        }\n    }\n</code>","url":"rest.html","anchor":"push-mode--push-via-web-socket"},{"objectID":"rest-api-push-mode--push-via-mqtt","hierarchy_lvl0":"Documentation","hierarchy_lvl1":"REST API","hierarchy_lvl2":"Push-Mode – Push via MQTT","content":" Push-Mode – Push via MQTT [DMM] The DASS can push data to applications via MQTT in two different modes; Host-mode where the DASS itself is the MQTT broker and the applications must connect directly to the MQTT broker of the DASS; And Client-mode where DASS will connect as a client to an external MQTT broker and publish data to the external broker. The data exchanged in either mode is the same but there are some differences in the way to use the two modes and some differences in topic names. MQTT - Client Mode In client mode, the DASS will open and maintain a connecting to a external MQTT broker. To create the connection, an application sub-account must be created. The application sub-account is then configure to push data to the MQTT broker. This is done using the /rest/pushmode/start command (see @sec:pushModeStart). The protocol name of the host must be set to mqtt:// or mqtts:// (for tls version of MQTT). The MQTT broker may require username/password, which can be provided to the pushmode/start command. Similarly, some brokers can rely on key authentication and requires the client connection be made with certain key/cert pair. This can equally be specified in the pushmode/start command. Below is an example of starting connection to a MQTT broker. <code class=\"language-JSON\">PUT /rest/pushmode/start\n\n{\n    \"host\": \"mqtts://mybroker.mydomain.com\",\n    \"port\": 8883,\n\n    \"push_auth_username\": \"myusername\",\n    \"push_auth_password\": \"mypassword\",\n\n    \"data_format\": \"hex\",\n    \"push_subscription\": \"payloads_ul,payloads_dl,nodeinfo,alarm\"\n}\n</code> As soon as this command has been execute, the DASS will establish and maintain the connection to the broker and start to push the subscribed messages to the broker. Once the connection is no longer needed, the /rest/pushmode/stop command should be invoked. The DASS will automatically maintain the connection to the broker. If the broker go down for a while and the DASS gets disconnected (either by protocol or simply by timeout), the DASS will continue to try to reestablish the connection. It should be noted that the DASS will apply a backoff scheme that will increase the period between retries. Hence if the broker has been down for a long time (days) it may take several minutes before the DASS reconnect after the broker is back up. For short broker disruptions the reconnection time is almost instant. Please see @sec:pushModeStart for more details of the /rest/pushmode/start command. Once the broker is connected the DASS will push data to the subscribed topics. The application must also connect its own client to the broker and subscribe to the needed topics. The names of the topics differ between client-mode and host-mode. In client mode the following topics are used. <code>payloads_ul_early\npayloads_ul\npayloads_dl\nmulticast\nnodeinfo\nstatus\njoin\t(* not currently available\njoininfo\nlocation\nalarm\n</code> These are the same topics as used in the push_subscription. The JSON payloads for the message is shown later in this chapter. MQTT - Host mode In host mode the DASS publish data to its own builtin MQTT broker. In this case the application must connect it MQTT client directly to the DASS. The DASS support both MQTT and MQTTs (TLS connection) protocols. To connect, the application must provide the username (for normal user accounts) or UUID (for application sub-accounts) and password from the account. Once the client is connected, the application must subscribe to the topics it wish to receive. Unlink in the case of the Client-mode, in host-mode the topics that are published to and subscribed to are prefixed with the name of the account. Account-ID is the username for a normal user account, and the UUID for an application sub-account. The available topic are: <code>Account-ID/payloads_ul_early\nAccount-ID/payloads_ul\nAccount-ID/payloads_dl\nAccount-ID/multicast\nAccount-ID/nodeinfo\nAccount-ID/status\nAccount-ID/join\t(* not currently available\nAccount-ID/joininfo\nAccount-ID/location\nAccount-ID/alarm\n</code> The first part of the channel name must be the username that was used to make the connection. Attempting to set another username will result in an authorization error on the subscription. Once a subscription has been made the DASS will send message to the application using the above listed channels. The payloads are in the same JSON format as their REST push versions. The REST message is encapsulated in an outer object with the name of the message type. I.e.: Default MQTT topics and JSON Message body The message body of the varies topics published on MQTT are identical to the messages pushed via REST and all other protocols, except that the JSON body is further encapsulated in an outer object with the same name as the topic. The lift of and message body JSON objects are shown in the table below. \n  \n    \n      MQTT topic\n      JSON body\n      Comment\n    \n  \n  \n    \n      [Account-ID/]payloads_ul_early\n      { \"payloads_ul_early\": {...} }\n      see @sec:pushPayloadUl\n    \n    \n      [Account-ID/]payloads_ul\n      { \"payloads_ul\": {...} }\n      see @sec:pushPayloadUl\n    \n    \n      [Account-ID/]payloads_dl\n      { \"payloads_dl\": {...} }\n      see @sec:pushPayloadDl\n    \n    \n      [Account-ID/]multicast\n      { \"multicast\": {...} }\n      see @sec:pushMulticast\n    \n    \n      [Account-ID/]nodeinfo\n      { \"nodeinfo\": {...} }\n      see @sec:pushNodeinfo\n    \n    \n      [Account-ID/]status\n      { \"status\": {...} }\n      see @sec:pushStatus\n    \n    \n      [Account-ID/]join\n      { \"join\": {...} }\n      see @sec:pushJoin\n    \n    \n      [Account-ID/]joininfo\n      { \"joininfo\": {...} }\n      see @sec:pushJoinInfo\n    \n    \n      [Account-ID/]location\n      { \"location\": {...} }\n      see @sec:pushLocation\n    \n    \n      [Account-ID/]alarm\n      { \"alarm\": {...} }\n      see @sec:pushAlarm\n    \n  \n Downlink via MQTT Downlink can be sent to a device via MQTT. Downloads must be sent to the following topics: topic: username/send_payloads_dl for client-mode and send_payloads_dl for host-mode <code class=\"language-JSON\">    {\n        \"payloads_dl\": {\n            \"confirmed\": true,                      // optional, defaults to true\n            \"deveui\": \"aabbccdd00000000\",\n            \"data\": \"aabbcc\",\n            \"port\": 10,\n            \"data_format\": \"base64\" | \"hex\",        // optional, default to base64\n            \"fcnt\": 12,                             // optional\n            \"mode\": \"fail_on_busy\",                 // optional, default to enqueue_on_busy\n            \"session_id\": \"uuid-of-session\",        // optional,\n            \"tag\": \"request-tag\"                    // optional\n        }\n    }\n</code> Upon reception of the downlink message, provided there are no errors, the DASS immediately send back the following message: topic: username/payloads_dl for client-mode and payloads_dl for host-mode <code class=\"language-JSON\">    {\n        \"payloads_dl\": {\n            \"deveui\": \"hex\",            // DevEUI of the receiving device\n            \"id\": 252,                  // unique ID of the dl payload\n            \"fcnt\": 10,                 // the used downlink FCNT\n            \"port\": 1,                  // the used port\n            \"transmissionStatus\": 0,\n            \"session_id\": \"UUID\",       // session ID when packet was created\n            \"tag\": \"request-tag\"\n        }\n    }\n</code> The transmissionStatus (see section @sec:postDownlink for valid values) is set to zero indicating that the payload has been enqueued. Note this message is only send back on MQTT and not pushed in general (i.e. applications listening for REST or Web-Socket will not receive this message). In the even of an error, the following error object is sent: topic: username/payloads_dl for client-mode and payloads_dl for host-mode. <code class=\"language-JSON\">    {\n        \"error\": {\n            \"tag\": \"request-tag\",           // reference to requesting message\n            \"error_msg\": \"error message\",\n            \"status_code\": 404              // REST style status code, e.g. 404 not found\n        }\n    }\n</code> Multicast via MQTT Multicast message can be sent via MQTT by sending the following message: topic: username/send_multicast for client-mode and send_multicast for host-mode <code class=\"language-JSON\">    {\n        \"multicast\": {\n            \"groupid\": \"group-id\",\n            \"data\": \"aabbcc\",\n            \"port\": 10,\n            \"data_format\": \"base64\" | \"hex\",        // optional, default to base64\n            \"fcnt\": 12,                             // optional\n            \"mode\": \"fail_on_busy\",                 // optional, default to enqueue_on_busy\n            \"tag\": \"free-text-tag\"                  // optional\n        }\n    }\n</code> topic: username/multicast for client-mode and multicast for host-mode <code class=\"language-JSON\">    {\n        \"multicast\": {\n            \"groupid\": \"group-id\",      // multicast group id\n            \"id\": 252,                  // unique ID of the dl payload\n            \"fcnt\": 10,                 // the used downlink FCNT\n            \"port\": 1,                  // the used port\n            \"transmissionStatus\": 0,\n            \"session_id\": \"UUID\",       // session ID when packet was created\n            \"tag\": \"request-tag\"\n        }\n    }\n</code> The transmissionStatus (see @sec:postDownlink for valid values) is set to zero indicating that the payload has been enqueued. Note this message is only send back on MQTT and not pushed in general (i.e. applications listening for REST or Web-Socket will not receive this message). In the even of an error, the following error object is sent: topic: username/multicast for client-mode and multicast for host-mode <code class=\"language-JSON\">    {\n        \"error\": {\n            \"tag\": \"request-tag\",           // reference to requesting message\n            \"error_msg\": \"error message\",\n            \"status_code\": 404              // REST style status code, e.g. 404 not found\n        }\n    }\n</code> Topic customization The topic names used with MQTT are fully customizable and are controlled by special tags assigned to the account used. This applies both to client mode and host mode. The tags used to control the MQTT (and topics for other broker types as well) are tags prefixed with broker_topic_. Each topic can be customized by appending the topic name, e.g. broker_topic_payloads_ul. A special tag broker_topic_any apply to all topics and can be used to change all topics with a single tag. Individual tag customization always has priority over broker_topic_any. The topic customization use parameter substitution which allow topics to be generated dynamically. The parameters that can be substituted are the general parameters defined in section @sec:customTags as well as all the parameters that are inside the message being pushed. The default topics as mentioned in the previous sections are actually defined with tags as follows: For host mode: <code>\"broker_topic_any\": \"${userid}/${topic}\"\n</code> and for client mode: <code>\"broker_topic_any\": \"${topic}\"\n</code> Some application server prefer to switch topics based directly on the deveui and it may be needed to provide the deveui in the topic path. This can be done this way: <code>\"broker_topic_any\": \"${deveui}/${topic}\"\n</code> Some application servers may require different specific topics. For example is a server expect a topic like this:  “uplink/aabbccdd00000000/120/data” (i.e.: uplink/{deveui}/{port}/data), that can be defined like this: <code>\"broker_topic_payloads_ul\": \"uplink/${deveui}/$(port)/data\"\n</code> As mention in previous section, the JSON payload also contains the topic by default. The JSON object is by default an outer object with onle inner object with the name of the topic. E.g. <code>{\n    \"topic\": {\n        body of topic\n    }\n}\n</code> This can be customized too with the broker_json_topic_ prefixed tags. Similar to the MQTT topics, it is possible to customise each topic individually as well as set a default using broker_json_topic_any. By default the following is defined: <code>\"broker_json_topic_any\": \"${topic}\"\n</code> The json topic can be customized in anyway using the same substitution as for the MQTT topic. To completely remove the JSON topic, and send directly the body of the topic, the topic can be set to a period “.”. Like this: <code>\"broker_json_topic_any\": \".\"\n</code> In this case the message sent on MQTT will have directly the message body as the message, i.e.: <code>{\n    body of topic\n}\n</code> Finally, the topic customization also works for the downlink topics where the application server is sending data back to OrbiWAN. Downlink is described in more detail in section @sec:mqttDownlink. The downlink topics are send_payloads_dl and send_multicast. These topics are customized exactly like the other topics. When parameter substitution is used, some of the parameters that is otherwise provided in the payload can be extracted from the topic. For example, in the above example with the deveui in the path i.e.: <code>\"broker_topic_any\": \"${deveui}/${topic}\"\n</code> When a downlink is set to e.g. aabbccdd00000000/send_payloads_dl, the deveui is automatically extracted from the topic path and inserted into the body JSON. In this case it is not necessary to add the deveui in the body. This can apply also to all the other parameters. For example: <code>\"broker_topic_send_payloads_dl\": \"${deveui}/${port}/downlink\"\n</code> In this example if we send to the topic: “aabbccdd00000000/120/downlink”, the deveui and the port number is automatically extracted from the topic and inserted into the body of the message, and we don’t need to provide them in the JSON. This can in some cases be very convenient when integrating with application servers that use the topics directly to exchange these kind of information. The inner json topic for the downlink topics are also controlled as for all other topics, so if setting the broker_json_topic_any or broker_json_send_payloads_dl to a period (“.”), then the downlink JSON must be provided directly in the body of the MQTT message without the JSON topic object.","url":"rest.html","anchor":"push-mode--push-via-mqtt"},{"objectID":"rest-api-push-customization","hierarchy_lvl0":"Documentation","hierarchy_lvl1":"REST API","hierarchy_lvl2":"Push Customization","content":" Push Customization Push notification is the “normal” way to receive data and status update from the DASS. The information is normally pushed to a dedicated applications that is able to process the message directly from the DASS. However often it is also desirable to push the information directly to some standard platform that is not designed to meet the standard format from the DASS, or may required some additional information to identify the device and/or user. The DASS push mechanism has some customizability to configure which messages are send (i.e. the subscription), how the target URL is generated, and what is included in the message body (for payloads). This section describes these topics. By default the URL use to send (REST based) push notifications is generated in the following way: <code>    http(s)://${host}:${port}{$path_prefix}\n</code> The ${} notation is used for variable substitution and in this case the host, port and path_prefix are the values set in pushmode/start API described in earlier sections. The topic_path depend on the type of message being pushed. The values are as follows: \n  \n    \n      Topic\n      topic_path\n      default subscription\n      default URL\n    \n  \n  \n    \n      payloads_ul_early\n      payloads/ul_early\n      disabled\n      POST https(s)://host:port/rest/callback/payloads/ul_early\n    \n    \n      payloads_ul\n      payloads/ul\n      enabled\n      POST https(s)://host:port/rest/callback/payloads/ul\n    \n    \n      payloads_dl\n      payloads/dl\n      enabled\n      PUT https(s)://host:port/rest/callback/payloads/dl\n    \n    \n      multicast\n      multicast\n      enabled\n      PUT https(s)://host:port/rest/callback/multicast\n    \n    \n      nodeinfo\n      nodeinfo\n      enabled\n      PUT https(s)://host:port/rest/callback/nodeinfo\n    \n    \n      status\n      status\n      enabled\n      PUT https(s)://host:port/rest/callback/status\n    \n    \n      join\n      join\n      *)\n      PUT https(s)://host:port/rest/callback/join\n    \n    \n      joininfo\n      joininfo\n      enabled\n      PUT https(s)://host:port/rest/callback/joininfo\n    \n    \n      location\n      location\n      **)\n      PUT https(s)://host:port/rest/callback/location\n    \n    \n      alarm\n      alarm\n      disabled\n      POST https(s)://host:port/rest/callback/alarm\n    \n  \n *) the join message is only sent when the DASS cannot find other means to process the join (i.e. no key nor join server specified).\n**) only for devices that have geo-location enabled. By default all notifications are send, except for the payloads_ul_early, are sent when the event occur. But for applications that does not need or does not understand some of the messages, the subscription field in the pushmode/start message should be specified to select only the needed messages. Typically for use-cases where payloads from as sensor should stored on some standard IoT platform, only the payloads_ul topic is relevant and the other messages should be disabled. URL customization The URL with the target server for the messages is specified in the pushmode/start message (please see section @sec:pushModeStart for the pushmode/start API) and set the following parameters \n  \n    \n      Parameter\n      Description\n    \n  \n  \n    \n      host\n      host address (domain name or IP address) and the protocol (http:// or https://)\n    \n    \n      port\n      port on the host\n    \n    \n      path_prefix\n      prefix added before standard topic path or complete path\n    \n  \n Example: <code>    \"host\": \"https://my.domain.com\",\n    \"port\": 9000,\n    \"path_prefix\", \"/dass_callback_api\"\n</code> Will result in the DASS pushing to the following URL for uplink message: <code>    POST https://my.domain.com/dass_callback_api/rest/callback/payloads/ul\n</code> This is the case when the the path_prefix contain a simple string. But the path_prefix can also contain parameters that are substituted dynamically and it is possible to completely control the format of the whole URL to avoid the standard “/rest/callback/payloads/ul” part of the URL. Parameter substitution is done with the following format ${parameter-name} where parameter-name is one of the following: \n  \n    \n      Parameter-name\n      Description\n    \n  \n  \n    \n      deveui\n      DevEUI of the device for which the push notification is being made\n    \n    \n      devaddr\n      DevAddr of the device for which the push notification is being made\n    \n    \n      devtags.xx\n      Custom tag ‘xx’ from the device for which the push notification is being made\n    \n    \n      usertags.yy\n      Custom tag ‘yy’ from the owner account that is making the push\n    \n    \n      topic\n      The topic of the push message (see table above)\n    \n    \n      topic_path\n      The topic path of the push message (see table above)\n    \n    \n      skip_topic\n      Returns empty string, but also remove the standard path from the URL and using only the path from the path_prefix.\n    \n  \n Example: <code>    \"host\": \"https://my.domain.com\",\n    \"port\": 9000,\n    \"path_prefix\", \"/dass_callback_api/${deveui}\"\n</code> Will resolve to (for a device with deveui=1234567812345678): <code>    POST https://my.domain.com/dass_callback_api/1234567812345678/rest/callback/payloads/ul\n</code> The following example illustrate how to customize the complete path: <code>    \"host\": \"https://my.domain.com\",\n    \"port\": 9000,\n    \"path_prefix\", \"${skip_topic}/dass_callback_api/uplink?deveui=${deveui}\"\n</code> resolve to: <code>    POST https://my.domain.com/dass_callback_api/uplink?deveui=1234567812345678\n</code> Notice how the ${skip_topic} in the path_prefix removes the standard /rest/callback/${topic_path} from the URL, making it possible to completely customizing the URL. This allows also to add query options (e.g. options after the ‘?’) to the URL. Custom tags It may often be needed to use additional information to identify devices and or users on some application platforms. I.e. some platforms may identify a device by some other ID than the deveui, that is normally used on the DASS. Some platforms may assign devices with an UUID or other ID that is required as part of the push notification in place of or in addition to the DevEUI. Similar for the account identification, a user account may need to present some additional ID as part of the push notification to be correctly identified. To accommodate such requirements the DASS has a feature of associating custom tags to both individual devices and to the owner account. These tags can be referenced by parameter substitution and hence can be used in the push notification URL. Example: Assign the following tags to a device: <code>    PUT /rest/nodes/1234567812345678\n\n    {\n        \"tags\": {\n            \"asset-id\": \"4dbba5dd-3284-4ec6-af67-25ddfe781e18\",\n            \"group\": \"sensors\"\n        }\n    }\n</code> These can be used in the URL as: <code>    \"host\": \"https://my.domain.com\",\n    \"port\": 9000,\n    \"path_prefix\", \"${skip_topic}/dass_callback_api/uplink?deveui=${deveui}&amp;asset=${devtags.asset-id}&amp;group=${devtags.group}\"\n</code> This resolves to: <code>    POST https://my.domain.com/dass_callback_api/uplink?deveui=1234567812345678&amp;asset=4dbba5dd-3284-4ec6-af67-25ddfe781e18&amp;group=sensors\n</code> Notice how tags associated with the device is resolved at runtime and the all device tags can be accessed using ${devtags.xx} where xx is the name of the tags. The names of the tags can be specified as any name as long as it uses only letters, number and the following symbols “-_.”. Tags for user accounts are used in the same way using the ${usertags.yy} substitution, where yy is the name of the tag that has been associated with the owning account. Note the usertags are liked to the owning account for the devices. That means that if an application sub-account is used for the push, the referenced tags are those of the actual user account not the application sub-account. Push HTTP Header The DASS will always make HTTP/HTTPS request using a properly formatted HTTP/1.1 request header with all HTTP header fields correctly set. This includes the common types such as “Content-Type” and “Content-Length”, etc. E.g.: <code>Content-Type: application/json\ncontent-Length: 139\nHost: my-host.com:10080\nConnection: keep-alive\n</code> Sometime it is required to provide additional header to e.g. identify a device directly from the header (where not possible to provide this information in the URL), e.g: <code>Content-Type: application/json\n...\nOne-Custom-Header-Device-Deveui: 1234567812345678\nAnother-Header-Account-Id: 4c8ab358-7f28-4471-872b-f55aff806d89\n</code> To enable this, some special tags can be use. These tags can be set on either the device, the application sub-account, or the account that own the device. To generate a header like the above, tags prefixed with “push_header_” and followed by the exact name of the header field, are used. These can be set on the user/application sub-account used to push the messages. E.g.: <code>PUT /rest/applications/my-push-app\n\n{\n    ...\n\n    \"tags\": {\n        \"push_header_One-Custom-Header-Device-Deveui\": \"${deveui}\",\n        \"push_header_Another-Header-Account-Id\": \"4c8ab358-7f28-4471-872b-f55aff806d89\"\n    },\n\n    ...\n}\n</code> In this example the two headers are added and the DASS will when pushing data it will add these two headers to the message. The content of the header fields are parsed by the normal keyword substitution function so as to be able to use variable names such as the DevEUI of the current device, as is described in section @sec:customTags. Note, only custom headers can be set in this way. Setting standard protocol headers (such as Content-Type, Accept, Content-Length, etc.) is not allowed and will return an error when trying to set the tags. Message body As specified in the previous sections, each push notification message has different payloads, but the payload is predefined. There are a few customizations possible that can be set in the data_format parameter in the /pushmode/start API. This field currently have the following three values: \n  \n    \n      data_format\n      Meaning\n    \n  \n  \n    \n      base64\n      Default. Message binary payloads given in base64 format string (https://tools.ietf.org/html/rfc4648)\n    \n    \n      hex\n      The message binary payload is in hex encoded string.\n    \n    \n      decoded_json\n      Only valid for payloads_ul and payloads_ul_early topics. Replace the normal message body with the content of the decoded field. If no decoded field is present the pushed object is an empty object.\n    \n  \n The “decoded_json” option will substitute the normal message body of a payloads_ul/payloads_ul_early with only the JSON of a decoded payloads, meaning that the message pushed has only the decoded valies of the sensor and no other “LoRa” related parameters. This can make integration with generic IoT platform easier in some cases. Example: An temperature sensor device that will normally push an uplink message like this (shortened): <code class=\"language-JSON\">{\n    \"confirmed\":true,\n    \"cr_used\":\"4/5\",\n    \"dataFrame\":\"AACq\",\n    \"decrypted\":true,\n    \"devaddr\":279387178,\n    \"dr_used\":\"SF7BW125\",\n    \"fcnt\":5,\n    \"freq\":865572500,\n    \"id\":1553768623768,\n    \"port\":8,\n    \"rssi\":-69,\n    \"session_id\":\"be20388f-3ee2-4d38-9794-bce44a28d8c0\",\n    \"sf_used\":7,\n    \"snr\":9,\n    \"time_on_air_ms\":51,\n    \"timestamp\":\"2019-03-28T10:23:43.768Z\",\n    \"decoded\": {\n        \"temperature\": 19.5,\n        \"humidity\": 25\n    }\n}\n</code> Will instead just push : <code class=\"language-JSON\">{\n    \"temperature\": 19.5,\n    \"humidity\": 25\n}\n</code> The content of the decoded object is specified by the associated payload decoder (see @sec:pluginFunctions on plugin functions) and can be customized to contain any fields.","url":"rest.html","anchor":"push-customization"},{"objectID":"rest-api-groups-and-multicast","hierarchy_lvl0":"Documentation","hierarchy_lvl1":"REST API","hierarchy_lvl2":"Groups and Multicast","content":" Groups and Multicast Groups are used to organize devices and can be used to query a subset of the devices for both reading status, but also to update device parameters. Groups are also used to send downlink data for multicast devices. If a group is to be used for multicasting, the group must have the nwkskey parameter set. Creating a new group Add a new group to an account. The group is created empty. After creating the group can be assigned to devices. <code>URL: https://dass-host[:port] /rest/groups\n</code> Method: POST \nDirection: application-&gt;DASS The following JSON object must be provided to create the group. <code class=\"language-JSON\">{\n    \"groupid\": \"group-id\",         // mandatory\n    \"title\": \"group title\",\t       // mandatory\n    \"comment\": \"text description\", // [optional]\n\n    // multicast parameters\n    \"nwkskey\": \"hex-key\",       // [optional]\n    \"appskey\": \"hex-key\",       // [optional]\n    \"devaddr\": 12345,\n    \"fcnt\": 0,                  // [optional]\n\n    \"data_rate\": 0,             // [optional]\n    \"freq\": 868.1,              // [optional]\n    \"ping_slot_periodicity\": 1, // [optional, for class B only]\n\n    \"applications\": \"appid1,appid2\"  // [optional]\n}\n</code> The applications field holds the list of applications that can access the group. Note, an application can only access device in the group that are also assigned to the application, i.e. having access to a group does not give access to the devices of the group, these must be added separately. Except for multicast downlink, in this case all devices in the group will be addressed in the multicast downlink, regardless if the application has access to the devices or not. \n  \n    \n      Status value\n      Meaning\n      Description\n    \n  \n  \n    \n      200\n      OK\n      Group was added successfully\n    \n    \n      400\n      Bad request\n      Something wrong with the JSON message\n    \n    \n      401\n      Unauthorized\n      The username/password used in the basic authentication scheme is invalid or not present.\n    \n    \n      403\n      forbidden\n      Application sub-accounts cannot create groups.\n    \n    \n      409\n       \n      Group ID already exists.\n    \n  \n Get group(s) info <code>URL: https://dass-host[:port] /rest/groups\nURL: https://dass-host[:port] /rest/groups/{group-id}\n</code> Method: GET \nDirection: application-&gt;DASS Read group properties. When specifying a group-id a single object is returned. If no id is specified on the URL an array with all groups is returned. <code class=\"language-JSON\">{\n     \"groupid\": \"group-id\",\t        // mandatory\n     \"title\": \"group title\",\t    // mandatory\n     \"comment\": \"text description\", // optional\n     \"nwkskey\": \"hex-key\",          // mandatory if group used for multicast\n     \"appskey\": \"hex-key\",          // optional\n     \"fcnt\": 0,\t\t\t            // optional\n\n     \"applications\": \"appid1, appid2\",\t// optional\n\n    // Class B multicast only\n    \"ping_slot_periodicity\": number,\n    \"data_rate\": number,\n    \"freq\": number\n}\n</code> <code class=\"language-JSON\">[\n    { \"groupid\": \"group-id\", \"title\": \"my group 1\", \"comment\": \"text description\"},\n    ...\n]\n</code> The list can be filtered by the following query filters: \n  application={app-id}, when this query is set, the devices associated to the specified application is returned.\n  search_id=group-id-string, will filter the groups according groupid name. The text is automatically “wildcarded” at both ends.\n  search_title=partial_title, text search of partial title\n \n  \n    \n      Status value\n      Meaning\n      Description\n    \n  \n  \n    \n      200\n      OK\n      Group was added successfully\n    \n    \n      401\n      Unauthorized\n      The username/password used in the basic authentication scheme is invalid or not present.\n    \n    \n      404\n      Not Found\n      Group not found.\n    \n  \n Delete a group Delete group from an account. <code>URL: https://dass-host[:port] /rest/groups/{group-id}\n</code> Method: DELETE \nDirection: application-&gt;DASS Deleting a group does NOT delete the devices, the devices remains registered under the account and can be assigned to another group. \n  \n    \n      Status value\n      Meaning\n      Description\n    \n  \n  \n    \n      200\n      OK\n      Group was deleted successfully\n    \n    \n      401\n      Unauthorized\n      The username/password used in the basic authentication scheme is invalid or not present.\n    \n    \n      403\n      Forbidden\n      Application sub-accounts cannot delete groups.\n    \n  \n \n  \n    \n      404\n      Not Found\n      Group not found.\n    \n  \n Update a group Update group information. <code>URL: https://dass-host[:port] /rest/groups/{group-id}\n</code> Method: PUT \nDirection: application-&gt;DASS Change parameters of a group. <code class=\"language-JSON\">{\n     \"groupid\": \"group-id\",\n     \"comment\": \"text description\",\n\n     \"nwkskey\": \"hex-key\",\n     \"appskey\": \"hex-key\",\n     \"fcnt\": 0\n}\n</code> Note, when changing the group-id subsequent references to the group will be only through the new id. \n  \n    \n      Status value\n      Meaning\n      Description\n    \n  \n  \n    \n      200\n      OK\n      Group was changed successfully\n    \n    \n      400\n      Bad request\n      Something wrong with the JSON message\n    \n    \n      401\n      Unauthorized\n      The username/password used in the basic authentication scheme is invalid or not present.\n    \n    \n      403\n      Forbidden\n      The application sub-account used does not have rights to change group parameter.\n    \n    \n      404\n      Not Found\n      Group with group-id not found.\n    \n  \n","url":"rest.html","anchor":"groups-and-multicast"},{"objectID":"rest-api-application-sub-accounts","hierarchy_lvl0":"Documentation","hierarchy_lvl1":"REST API","hierarchy_lvl2":"Application Sub-Accounts","content":" Application Sub-Accounts Application sub-accounts can be added to any user or customer account (the “owning account”) and is used to associate a sub-set of the owning accounts devices. The application sub-account has its own auto generated credentials that can be safely provided to an application without giving access to the owning accounts credentials. Application sub-accounts created from the DASS-UI uses the password given when creating the application sub-account. The application sub-account functions seamlessly as a normal user or customer account, but give the application access to only the associated subset of devices. The other devices remain invisible to the application sub-account. Also, the rights of the application sub-account can be set to subset of the owning account, meaning that the application can be restricted to not see certain data (like location, gateway info, etc.), while the owning account may have these rights. Application sub-account ids are only unique within the same owning account. Application sub-accounts use the same basic authentication scheme as normal account with the exception that where owning accounts have unique account names, the application sub-account names are unique only within the same user account. Therefore, the account UUID can be used as the user-name for the basic authentication. The UUID is returned on the POST of the account creation (see @sec:postApplication). The UUID is also used in the topic subscription and for MQTT. Alternatively, the basic authentication user-name can also be constructed in the following way (for convenience): <code>#app.{app-account-name}#{user-account-name} (e.g. “#app.myapp#myuser”)\n</code> However, this notation only works for the REST API and cannot be used with MQTT and possibly other future broker systems. It is therefore recommended to use the UUID method. Create new application sub-account Create a new application sub-account under the owning account. <code>URL: https://dass-host[:port] /rest/applications Method: POST \\ Direction: application-&gt;DASS\n</code> The parameters are like those of the owning accounts, except that administration rights cannot be assigned to an application sub-account and the account is “read-only” meaning that application sub-account cannot modify its own parameters. The parameters that can be set are: <code class=\"language-JSON\">{\n    \"accountid\": \"application-id\",// name or id of application\n    \"password\": \"passwd\",\t\t// password, optional, if not provided, it\n                                 // is auto generated.\n    \"can_register\": true,\t\t// can administer device\n    \"can_access_gtw_info\": true,\t// will receive info about\n                                // gateways that received messages\n                                // and can query position\n                                // of general gateways\n    \"can_own_gtw\": true,\t\t// can own gateways\n    \"can_add_gtw\": false,\t\t// can add/remove gateways\n    \"can_mng_gtw\": false,\t\t// can manage setting on gateway\n    \"loraloc_enable\": true\t\t// can enable lora location on\n            \t\t\t\t\t// devices\n}\n</code> Unlike the owning account name that must be globally unique, the application sub-account name must be unique only within the owning account. Once created the following object is returned: <code class=\"language-JSON\">{\n    \"accountid\": \"application-id\",// name or id of application given in the\n\t\t\t\t\t  //request\n    \"app_uuid\": \"APP.UUID\",\n    \"password\": \"passwd\"\n}\n</code> The app_uuid field value returned is the auto generated user credential created to be used when accessing the account via the REST API. The password return on the return object must be read and stored as it cannot be queried again. \n  \n    \n      Status value\n      Meaning\n      Description\n    \n  \n  \n    \n      200\n      OK\n      Application was added successfully\n    \n    \n      400\n      Bad request\n      Something wrong with the JSON message\n    \n    \n      401\n      Unauthorized\n      The username/password used in the basic authentication scheme is invalid or not present.\n    \n    \n      403\n      Forbidden\n      Account does not have administration rights\n    \n    \n      409\n       \n      Application ID already exists.\n    \n  \n Get application sub-account info Get application sub-account information from the owning account. <code>URL: https://dass-host[:port] /rest/applications[/{&lt;application-id &gt;}] Method: GET \\ Direction: application-&gt;DASS\n</code> Read the parameters of an application sub-account, or all application sub-accounts. When querying an account, the following object is returned. <code class=\"language-JSON\">{\n    \"accountid\": \"application-id\",\n    \"app_uuid\": \"APP.UUID\",\n    \"can_register\": true,\t\t// can administer device\n    \"can_access_gtw_info\": true,\n    \"can_own_gtw\": true,\t\t// can own gateways\n    \"can_add_gtw\": false,\t\t// can add/remove gateways\n    \"can_mng_gtw\": false,\t\t// can manage setting on gateway\n    \"loraloc_enable\": true,\t    // can enable lora location on\n            \t\t\t\t\t// devices\n}\n</code> When querying for all accounts, an array of the above object is returned: <code class=\"language-JSON\">    [ {\"accountid\": \"application-id\",\n\n    … },{\n    … }]\n</code> Optional filters: \n  “all=true” returns all additional information about the application, incl. push mode status. When this query is included all field from the /rest/pushmode/status is included in the message.\n \n  \n    \n      Status value\n      Meaning\n      Description\n    \n  \n  \n    \n      200\n      OK\n      User was added successfully\n    \n    \n      401\n      Unauthorized\n      The username/password used in the basic authentication scheme is invalid or not present.\n    \n    \n      403\n      Forbidden\n       \n    \n    \n      404\n      Unknown\n      Unknown application-id in URL.\n    \n  \n Modify application sub-account info Modify an application sub-account <code>URL: https://dass-host[:port] /rest/applications/{app-id} Method: PUT \\ Direction: application-&gt;DASS\n</code> Modify parameters of an application sub-account. All parameters listed in @sec:postApplication can be modified except the “accountid” that cannot be changed. \n  \n    \n      Status value\n      Meaning\n      Description\n    \n  \n  \n    \n      200\n      OK\n      Command was successful\n    \n    \n      400\n      Bad request\n      Something wrong with the JSON message\n    \n    \n      401\n      Unauthorized\n      The username/password used in the basic authentication scheme is invalid or not present.\n    \n    \n      403\n      Forbidden\n      Account does not have administration rights to modify target user\n    \n    \n      404\n      Unknown\n      Unknown application-id in URL.\n    \n  \n Delete application sub-account Delete an application sub-account <code>URL: https://dass-host[:port] /rest/applications/{app-id}\n</code> Method: DELETE \nDirection: application-&gt;DASS Delete application sub-account. When an application sub-account is deleted, no devices gets deleted, but reference to the application from the device is automatically removed, and if the application gets created again the association of devices to application has to be done again. \n  \n    \n      Status value\n      Meaning\n      Description\n    \n  \n  \n    \n      200\n      OK\n      User was added successfully\n    \n    \n      401\n      Unauthorized\n      The username/password used in the basic authentication scheme is invalid or not present.\n    \n    \n      404\n      Not found\n      Application sub-account is not known.\n    \n  \n","url":"rest.html","anchor":"application-sub-accounts"},{"objectID":"rest-api-gateway-api","hierarchy_lvl0":"Documentation","hierarchy_lvl1":"REST API","hierarchy_lvl2":"Gateway API","content":" Gateway API Get List with Information about Gateways Get list with information about all gatewaysassociated to an account. <code>URL: https://dass-host[:port] /rest/gateways Method: GET \\ Direction: application-&gt;DASS\n</code> A JSON payload with the following content is returned: <code class=\"language-JSON\">[\n    {\n        \"id\": \"0000000008050313\",\n        \"name\": \"313 Labo\",\n        \"address\": {},\n        \"latitude\": 46.21025,\n        \"longitude\": 2.922363,\n        \"antenna_gain\": 3,\n        \"position_valid\": true,\n        \"status\": \"OK\",\n        \"backhaul_type\": \"WIRED\",\n        \"backhaul_cell_operator\": \"\",\n        \"backhaul_cell_rssi\": \"N/A\"\n    },\n    …\n]\n</code> Return values \n  \n    \n      Status value\n      Meaning\n      Description\n    \n  \n  \n    \n      200\n      OK\n      Command was successful\n    \n    \n      401\n      Unauthorized\n      The username/password used in the basic authentication scheme is invalid or not present.\n    \n  \n Get Information about a Gateway Get information about a particular gateway. If the gateway is associated to the account, the full list of information is returned. If the account has can_access_gtw_info right, this command can be used to query any gateway in the network, however, only the location (latitude / longitude) information is provided. <code>URL: https://dass-host[:port] /rest/gateways/{gateway-id} Method: GET \\ Direction: application-&gt;DASS\n</code> The following JSON message is returned for devices that is associated to the account: <code class=\"language-JSON\">    {\n        \"id\": \"0000000008050313\",\n        \"name\": \"313 Labo\",\n        \"address\": {\n            \"address\": \"my street\",     // optional\n            \"city\": \"Geneva\",           // optional\n            \"zipcode\": \"1200\",          // optional\n            \"country\": \"switzerland\"    // optional\n        },\n        \"latitude\": 46.21025,\n        \"longitude\": 2.922363,\n        \"antenna_gain\": 3,\n        \"position_valid\": true,\n        \"status\": \"OK\",\n        \"backhaul_type\": \"Wired\",\n        \"backhaul_cell_operator\": \"\",\n        \"backhaul_cell_rssi\": \"N/A\"\n    }\n</code> For gateways that are not associated, but for accounts with can_access_gtw_info rights, the following is returned: <code class=\"language-JSON\">    {\n        \"id\": \"0000000008050313\",\n  \"latitude\": 46.21025,\n        \"longitude\": 2.922363\n    }\n</code> Return values \n  \n    \n      Status value\n      Meaning\n      Description\n    \n  \n  \n    \n      200\n      OK\n      Command was successful\n    \n    \n      400\n      Bad request\n      Something wrong with the JSON message\n    \n    \n      401\n      Unauthorized\n      The username/password used in the basic authentication scheme is invalid or not present.\n    \n    \n      404\n      Unknown gateway\n      The gateway with gateway-id was not found.\n    \n  \n Associate gateway with user / customer Associate a gateway to an account. Once associated, status of this gateway can be queried from the account. <code>URL: https://dass-host[:port] /rest/gateways/{gateway-id} Method: POST \\ Direction: application-&gt;DASS\n</code> This command takes an optional JSON body with properties of the association. Currently no properties are defined but will be added in later releases. <code class=\"language-JSON\">{\n}\n</code> Return values \n  \n    \n      Status value\n      Meaning\n      Description\n    \n  \n  \n    \n      200\n      OK\n      Command was successful\n    \n    \n      400\n      Bad request\n      Something wrong with the JSON message\n    \n    \n      401\n      Unauthorized\n      The username/password used in the basic authentication scheme is invalid or not present.\n    \n    \n      403\n      Forbidden\n      Account doesn’t have rights to associate the gateway\n    \n  \n Un-associate gateways Remove (un-associate) a gateway to an account. <code>URL: https://dass-host[:port] /rest/gateways/{gateway-id} Method: DELETE \\ Direction: application-&gt;DASS\n</code> Return values \n  \n    \n      Status value\n      Meaning\n      Description\n    \n  \n  \n    \n      200\n      OK\n      Command was successful\n    \n    \n      401\n      Unauthorized\n      The username/password used in the basic authentication scheme is invalid or not present.\n    \n    \n      403\n      Forbidden\n      Account doesn’t have rights to associate the gateway\n    \n    \n      404\n      Unknown gateway\n       \n    \n  \n Profiles OrbiWan from release 6 uses profiles to manage the increasingly complex set of parameters that are needed to manage devices. Two kind of profiles are assigned to each device. A device profile and a service profile. The device profile described the device parameters such as the version LoRaWAN MAC, device capabilities, supported regions, etc. The information needed to create a device profile must typically be provided by the device manufacturer. Device profiles can be created by the network operator but can also be created by the customers/users. Devices of same kind normally use the same device profile. The service profile defines the way the network will manage the device. This includes the QoS, allowed traffic volume, etc. This profile is always created by the network operator and is assigned to customers. Customers with elevate rights may in some cases define their own service profiles, but this is not the common case. When a customer/user register a new device a device profile and service profile must be selected and provided in the registration message. The customer/user can see a list of available profile through the API. Profiles can be created as links and referenced from other accounts. For example a customer may create a device profile at the root level of the customer account, and then share this profile as links to some of its users. As it is a link, if the root profile is changed, the change will automatically apply to all the linked usages of the profile. A customer can also chose to make profiles at the customer level visible to all its user accounts (without using linking). Profiles are managed by a number of APIs, with separate API for each kind of profiles. However all profiles use a very similar API the following section describes the API in general as the same applies to all kinds of profiles. Each particular API is then described in full detail in the subsequent sections.","url":"rest.html","anchor":"gateway-api"},{"objectID":"rest-api-profile-api-summary","hierarchy_lvl0":"Documentation","hierarchy_lvl1":"REST API","hierarchy_lvl2":"Profile API Summary","content":" Profile API Summary Profiles are manipulated using the following commands: <code>GET /rest/xx-profiles\nGET /rest/xx-profiles?get_schema=true\nGET /rest/xx-profiles/{uuid}\nPOST /rest/xx-profiles\nPUT /rest/xx-profiles/{uuid}\nDELETE /rest/xx-profiles/{uuid}\n</code> The rights to access these APIs are governed by the the following account rights: \n  can_list_xx_profiles\n  can_inspect_xx_profiles\n  can_create_xx_profiles\n  can_link_xx_profiles\n There are different kind of profiles, but they are all managed in similar way, as described in the following sections. The exact details for all the API are described in following separate sections. The following profiles exists, and the “xx” in all API and rights can be replaced according to following table. \n  \n    \n      Name\n      “xx”\n      Description\n    \n  \n  \n    \n      Device-Profile\n      device\n      The device-profile describes the common device parameters and capabilities. Each device must be assigned a device profile, and devices of same kind will be assigned the same device profile. The input for this profile is normally provided by the device manufacturer. I contains elements like version of the LoraWAN spec, default frequency values, support for features such as Class B/C mode, etc.\n    \n    \n      Service-Profile\n      service\n      Device are managed by the network according to the service-profile. Each device must be assigned a service profile. Often all devices will be assigned the same service profile, but devices with very different requirements in QoS will need different service profiles. Service profiles are generally created only by the operator and normal users can only select from a list of predefined profiles. It is possible to create links of a service-profile and apply restrictions to the profile essentially “downgrading” the service. The restricted version of service profile can be assigned to devices same way as a “normal” service profile.\n    \n  \n Create a Profile Profiles are created with the POST command. <code>    POST /rest/xx-profile\n</code> <code class=\"language-JSON\">    {\n        \"description\": \"text description of profile\",\n        \"profile_name\": \"name-of-profile\",\n        \"notes\": \"internal notes about this profile\",\n        \"shared_with_all_users\": false,\n\n\"content\": {\n            // profile specific fields\n        }\n    }\n</code> \n  \n    \n      Field\n      type\n      Description\n    \n  \n  \n    \n      profile_name\n      string\n      Name of the profile. Mandatory field. Must be valid string of 6 or more characters (up to 64).\n    \n    \n      description\n      string\n      Textual description of the profile for convenience\n    \n    \n      notes\n      string\n      “private” notes about this profile. The notes field can only be seen by the profile owner.\n    \n    \n      shared_with_all_users\n      boolean\n      Set this flag to make the profile visible to all users belonging to the customer. This flag is only valid for profiles created under a customer.\n    \n    \n      content\n      object\n      profile specific parameters\n    \n  \n If the profile was created OK, the command will return status 200 and return the following JSON object: <code class=\"language-JSON\">    {\n        \"profile_uuid\": \"uuid-of-new-created-profile\"\n    }\n</code> The returned UUID of the created profiles is the ID that must be used to reference the profile later. Return status values: \n  \n    \n      Status\n      Description\n    \n  \n  \n    \n      200\n      Profile created ok. return message contains above JSON object with created UUID.\n    \n    \n      400\n      Invalid profile definition. Inspect the returned text string for further clues about the reason for failure.\n    \n    \n      401\n      Unauthorized. Invalid account or password\n    \n    \n      403\n      Forbidden. The account does not have sufficient rights for the requested operation.\n    \n    \n      404\n      Referenced profiles (for service profile only) not found.\n    \n  \n Create a Linked Profile Profiles can be linked across accounts and can be re-linked multiple times (i.e. link to link to link etc.). When a link is created, the account that create the link must have access to both the owning account and target account, which means only administrators can create links across accounts. Links can be create only by accounts that have the can_link_xx_profiles right. When a link is created, the right to inspect the content of the profile can be set. If this not set, the target account user will be able to see the profile in the list of profile, but will not be able to see the content (even when having the can_inspect_xx_profiles right). Linked profiles have the exact same properties of the root profile, but can be renamed have different description. Also the sharing for the profile can be set independently of the root profile. If the root profile is changed all linked profiles will automatically get the new properties of the root profile. The right to create a link to a profile (can_link_xx_profiles) is deliberately separate from the right to create a profile (can_create_xx_profiles). This a allow a separation in responsibility in where some accounts has the right to create the profiles, which requires some technical insight into LoraWan, and have other accounts be responsible for the assignment of these profiles. In this case a local administrator may be able to create links on varies accounts giving access to profiles already created and tested. Creating a link uses the same API as creating a profile: <code>    POST /rest/xx-profile\n</code> However the JSON message body does not contain the actual profile data, but a reference (by UUID) to the profile that is to be linked. The account that is creating the link must have rights to both create a link on the target account, and have right to access the profile on the account where it is being linked from. The message body looks as follows: <code class=\"language-JSON\">    {\n        \"description\": \"text description of profile\",\n        \"profile_name\": \"name-of-profile\",\n\n        \"shared_with_all_users\": false,\n        \"can_be_inspected\": true,\n        \"userid\": \"target-user.id\",\n\n        \"link_to_profile_uuid\": \"uuid-of-target-profile\"\n    }\n</code> \n  \n    \n      Field\n      type\n      Description\n    \n  \n  \n    \n      profile_name\n      string\n      Name of the profile\n    \n    \n      description\n      string\n      Textual description of the profile for convenience\n    \n    \n      can_be_inspected\n      boolean\n      If this flag is set, the profile content (of the linked profile) may be viewed via the link (if the account also have the can_inspect_xx_profiles right). If set to false, the content of the actual profile cannot be viewed.\n    \n    \n      userid\n      string\n      Administrators may specify directly the target user ID when assigning links to profile to other users.\n    \n    \n      shared_with_all_users\n      boolean\n      Set this flag to make the profile visible to all users belonging to the customer. This flag is only valid for profiles created under a customer.\n    \n    \n      content\n      object\n      profile specific parameters\n    \n    \n      link_to_profile_uuid\n      string\n       \n    \n  \n Upon success a JSON object is returned with the UUID of the new profile that is linked to the original profile. <code class=\"language-JSON\">    {\n        \"copy_from_profile_uuid\": \"uuid-of-target-profile\"\n    }\n</code> Unlinking profile An linked profile can be “unlinked” and turned in to a profile by itself. If a profile has the can_be_inspected rights set, accounts that has can_create_xx_profiles rights, can directly unlink the profile and turn it into a local profile. This profile can then be modified.\nThis can be done with the copy_from_profile_uuid. <code>    PUT /rest/xx-profile{uuid}\n</code> <code class=\"language-JSON\">    {\n        \"copy_from_profile_uuid\": \"uuid-of-target-profile\"\n    }\n</code> Setting the target profile UUID to the same as the current linked profile, if the Profile JSON schema Profiles are fairly complex JSON object. For convenience it is possible to query a JSON schema object for all the profile types. The schema is always up-to-date and contains both JSON definition and description for all fields. To query the schema for profile, use the following query: <code>    GET /rest/xx-profiles?get_schema=true\n</code> The returned scheme applies to direct profile manipulation (i.e. not linked profiles). To get schema for linked profiles use the following query; <code>    GET /rest/xx-profiles?get_link_schema=true\n</code>","url":"rest.html","anchor":"profile-api-summary"},{"objectID":"rest-api-device-profile","hierarchy_lvl0":"Documentation","hierarchy_lvl1":"REST API","hierarchy_lvl2":"Device Profile","content":" Device Profile This section the API for Device Profiles. Access to the device profile API controlled by the following rights: \n  can_list_device_profiles\n  can_inspect_device_profiles\n  can_create_device_profiles\n  can_link_device_profiles\n The individual API are described in the following sections. Create Device Profile Accounts that has the can_create_device_profiles and/or can_link_device_profiles rights can create new device profiles or link existing device profiles respectively using the following REST command: <code>    POST /rest/device-profiles\n</code> When creating a new profile, the following parameters must be provided: <code class=\"language-JSON\">{\n    \"description\": \"text description of profile\",\n    \"profile_name\": \"name-of-profile\",\n    \"payload_decoder_js\": \"javascript code\",\n    \"content\":\n        {\n            \"activation\": \"OTAA\",\n            \"RFRegion\": \"EU868\",\n            \"MACVersion\": \"1.0.2\",\n            \"RegParamsRevision\": \"A\",\n            \"MaxEIRP\": 14,\n            \"DefaultDeviceClass\": \"CLASS_A\",\n            \"SupportsClassB\": true,\n            \"SupportsClassC\": true,\n            \"transmit_capable_only\": false,\n            \"lora_fcnt32bits\": true,\n            \"dl_max_size_app_payload\": 64,\n            \"dl_max_size_phy_payload\": 64,\n            \"dl_max_num_mac_cmd\": 3,\n            \"dl_max_size_mac_cmd\": 16,\n            \"support_fuota\": true,\n            \"mobile_device\": false,\n            \"persisted_fcnt\": \"AUTO\",\n            \"persistent_nonce_counters\": \"AUTO\",\n            \"factory_presets\": [\n                {\n                    \"RFRegion\": \"EU868\",\n                    \"MaxEIRP\": 14,\n                    \"ul_dwell_time\": 0,\n                    \"dl_dwell_time\": 0,\n                    \"adr_ack_limit\": 6,\n                    \"adr_ack_delay\": 5,\n                    \"max_time_between_rejoin_req\": 0,\n                    \"max_num_of_ul_between_rejoin_req\": 0,\n                    \"min_ul_dr_supported\": 0,\n                    \"max_ul_dr_supported\": 6,\n                    \"rx2_dr\": 2,\n                    \"rx2_freq_mhz\": 868,\n                    \"rx1_delay\": 1,\n                    \"rx1_dr_offset\": 0,\n                    \"ping_slot_freq_mhz\": 868,\n                    \"ping_slot_dr\": 0,\n                    \"ping_slot_periodicity\": 0,\n                    \"channels\": [\n                        {\n                            \"freq_mhz\": 0,\n                            \"dr_min\": 0,\n                            \"dr_max\": 0,\n                            \"masked\": false,\n                            \"dl_freq_mhz\": 433\n                        }\n                    ],\n                    \"mask_125khz\": \"FFFFFFFFFFFFFFFF\",\n                    \"mask_500khz\": \"FF\",\n                    \"freq_change_not_supported\": false\n                }\n            ]\n        }\n\n}\n</code> The profile specific content parameters are described in the table below: \n  \n    \n      Field\n      type\n      Description\n    \n  \n  \n    \n      activation\n      string\n      Device activation modeMandatory. Valid values: “OTAA”, “ABP”\n    \n    \n      RFRegion\n      string\n      LoRaWAN regionMandatory. Valid values: “EU868”, “US915”, “AU915”, “CN470”, “AS923”, “AS923-2”, “AS923-3”, “IN865”, “RU864”, “JP923”\n    \n    \n      MACVersion\n      string\n      LoRaWAN MAC versionMandatory. Valid values: “1.0.0”, “1.0.1”, “1.0.2”, “1.0.3”, “1.0.4”, “1.1.1”\n    \n    \n      RegParamsRevision\n      string\n      LoRaWAN MAC regional parameters revisionMandatory. Valid values: “A”, “B”, “RP002-1.0.0”, “RP002-1.0.1”, “RP002-1.0.2”\n    \n    \n      MaxEIRP\n      integer\n      Max EIRP [dBm]Set the device max Equivalent Isotropically Radiated Power (EIRP). This is maximum EIRP capability of the device (not necessarily the default value)Mandatory. Valid range: [0;33]\n    \n    \n      DefaultDeviceClass\n      string\n      Default class of device after resetMandatory. Valid values: “CLASS_A”, “CLASS_B”, “CLASS_C”\n    \n    \n      SupportsClassB\n      boolean\n      Supports Class BMandatory.\n    \n    \n      SupportsClassC\n      boolean\n      Supports Class CMandatory.\n    \n    \n      transmit_capable_only\n      boolean\n      Transmit capable only device cannot receive downlink (i.e. it has no receiver). When this is set the network will never send any downlink towards the deviceMandatory.\n    \n    \n      lora_fcnt32bits\n      boolean\n      FCNT 32-bit counter (for 1.0.x devices only)Select the size of the FCNT counterMandatory.\n    \n    \n      dl_max_size_app_payload\n      integer\n      Max accepted downlink application payload size [bytes]Mandatory. Valid range: [0;242]\n    \n    \n      dl_max_size_phy_payload\n      integer\n      Max accepted downlink PHY Payload size [bytes]Mandatory. Valid range: [20;255]\n    \n    \n      dl_max_num_mac_cmd\n      integer\n      Max number of MAC commands in each downlink messageMandatory. Valid range: [2;7]\n    \n    \n      dl_max_size_mac_cmd\n      integer\n      Max accepted size of MAC commands in downlink message [bytes]Mandatory. Valid range: [11;64]\n    \n    \n      support_fuota\n      boolean\n      Device support Firmware Update Over The Air (FUOTA)Mandatory.\n    \n    \n      mobile_device\n      boolean\n      Device is mobile and may be in a new location from uplink to uplink.Optional.\n    \n    \n      persisted_fcnt\n      string\n      Device persist the FCNT and keep the FCNT value on device resetMandatory. Valid values: “AUTO”, “YES”, “NO”\n    \n    \n      persistent_nonce_counters\n      string\n      Use persistent nonce counters for JOIN. OTAA devices can use either random values or sequential counters that are persisted (i.e. values are never reset even if the power is off the device) for the Nonce in the JOIN procedure. Normally this scheme is determined by the MAC version, however some devices have chosen one scheme or the other regardless of the MAC version used.Optional. Valid values: “AUTO”, “YES”, “NO”\n    \n    \n      factory_presets[]. RFRegion\n      string\n      LoRaWAN regionMandatory. Valid values: “EU868”, “US915”, “AU915”, “CN470”, “AS923”, “AS923-2”, “AS923-3”, “IN865”, “RU864”, “JP923”\n    \n    \n      factory_presets[]. MaxEIRP\n      integer\n      Max EIRP [dBm]Set the device max Equivalent Isotropically Radiated Power (EIRP). This is default value used for the current region (not necessarily the maximum capability)Mandatory. Valid range: [0;33]\n    \n    \n      factory_presets[]. ul_dwell_time\n      integer\n      Uplink dwell time (AU915, AS923, AS923-2, AS923-3 and JP923 regions only)Set 0 for no constraint, 1 for 400msOptional. Valid values: 0, 1\n    \n    \n      factory_presets[]. dl_dwell_time\n      integer\n      Downlink dwell time (AU915, AS923, AS923-2, AS923-3 and JP923 regions only)Set 0 for no constraint, 1 for 400msOptional. Valid values: 0, 1\n    \n    \n      factory_presets[]. adr_ack_limit\n      integer\n      ADR_ACK_LIMIT as defined in LoraWan specificationOptional. Valid range: [0;15]\n    \n    \n      factory_presets[]. adr_ack_delay\n      integer\n      ADR_ACK_DELAY as defined in LoraWan specificationOptional. Valid range: [0;15]\n    \n    \n      factory_presets[]. max_time_between_rejoin_req\n      integer\n      Max time between rejoin attempts [seconds] (LoraWan 1.1 only)Optional. Valid range: [0;15]\n    \n    \n      factory_presets[]. max_num_of_ul_between_rejoin_req\n      integer\n      Max number of uplinks between REJOIN requests (LoraWan 1.1 only)Optional. Valid range: [0;15]\n    \n    \n      factory_presets[]. min_ul_dr_supported\n      integer\n      Minumum uplink data-rate supported. This may be needed as some devices use payloads sizes incompatible with the lower datarates.Optional. Valid range: [0;15]\n    \n    \n      factory_presets[]. max_ul_dr_supported\n      integer\n      Highest uplink data-rate supportedMandatory. Valid range: [0;15]\n    \n    \n      factory_presets[]. rx2_dr\n      integer\n      Default data-rate of RX2 downlink slotMandatory. Valid range: [0;15]\n    \n    \n      factory_presets[]. rx2_freq_mhz\n      number\n      Default frequency [MHz] of RX2 downlink slotMandatory. Valid range: [433;930]\n    \n    \n      factory_presets[]. rx1_delay\n      number\n      Default delay [seconds] of RX1 downlink slot after TX slotOptional. Valid range: [1;15]\n    \n    \n      factory_presets[]. rx1_dr_offset\n      number\n      Default data-rate offset between uplink and downlinkOptional. Valid range: [0;15]\n    \n    \n      factory_presets[]. ping_slot_freq_mhz\n      number\n      Default frequency [MHz] of class B ping-slot. When set to 0 the hopping slot is used.Mandatory. Valid range: [433;930]\n    \n    \n      factory_presets[]. ping_slot_dr\n      number\n      Default data-rate of class B ping-slotMandatory. Valid range: [0;15]\n    \n    \n      factory_presets[]. ping_slot_periodicity\n      number\n      Class B periodicity of ping-slotMandatory. Valid range: [0;15]\n    \n    \n      factory_presets[]. channels[]. freq_mhz\n      number\n      Channel frequency [MHz]Mandatory.\n    \n    \n      factory_presets[]. channels[]. dr_min\n      integer\n      Mandatory. Valid range: [0;8]\n    \n    \n      factory_presets[]. channels[]. dr_max\n      integer\n      Mandatory. Valid range: [0;8]\n    \n    \n      factory_presets[]. channels[]. masked\n      boolean\n      channel disabled (masked)Mandatory.\n    \n    \n      factory_presets[]. channels[]. dl_freq_mhz\n      number\n      Downlink frequency if different from uplink frequency [MHz]Optional. Valid range: [433;940]\n    \n    \n      factory_presets[]. channels\n      array\n      Channels DefinitionOptional.\n    \n    \n      factory_presets[]. mask_125khz\n      string\n      Channel mask for 125kHz channelsOptional.\n    \n    \n      factory_presets[]. mask_500khz\n      string\n      Channel mask for 500kHz channelsOptional.\n    \n    \n      factory_presets[]. freq_change_not_supported\n      boolean\n      Device frequency list is fixed and cannot be changed by networkOptional.\n    \n    \n      factory_presets\n      array\n      Device factory settingsIf the factory presets are not provided the network will use LoraWan regional default settings for the region.Mandatory.\n    \n  \n For creating a link please see @sec:createLinkedProfile. Return values: \n  \n    \n      Status\n      Description\n    \n  \n  \n    \n      200\n      Device Profile created ok. return message contains above JSON object with created UUID.\n    \n    \n      400\n      Invalid profile definition. Inspect the returned text string for further clues about the reason for failure.\n    \n    \n      401\n      Unauthorized. Invalid account or password\n    \n    \n      403\n      Forbidden. The account does not have sufficient rights for the requested operation.\n    \n  \n List Device Profiles Accounts that have can_list_device_profiles rights can use the following REST commands to list the available devices profiles accessible by this account. <code>    GET /rest/device-profiles?[query-options]\n</code> The following query-options are available. \n  \n    \n      Query option\n      Description\n    \n  \n  \n    \n      get_pages\n      Get list of page links to be used with paged queries. See section “Paged Queries”.\n    \n    \n      limit\n      Set number of items per page. Used with paged queries. See section “Paged Queries”.\n    \n    \n      page_state\n      Set the page state to start the query from where the previous query finished or jump to any page returned by the get_pages option. See section “Paged Queries”.\n    \n    \n      paged_results\n      Return results in paged format. See section “Paged Queries”.\n    \n    \n      strict\n      Force strict parameter and options checking. Should be used during development only and not used in production code.\n    \n    \n      get_schema\n      Return the JSON schema used to define a device profile.\n    \n    \n      search_name\n      Return only profiles that match the search criteria on the profile name.\n    \n    \n      search_description\n      Return only profiles that match the search criteria on the profile description.\n    \n    \n      search_linked\n      set true or false to return only profiles that are linked or not linked\n    \n    \n      search_shared\n      set true or false to return only profiles that are shared with all users or not.\n    \n    \n      sort_by_name\n      set to asc (ascending) or desc (descending) to sort the result according to the name.\n    \n    \n      sort_by_uuid\n      set to asc (ascending) or desc (descending) to sort the result according to the profile UUID.\n    \n    \n      sort_by_description\n      set to asc (ascending) or desc (descending) to sort the result according to the profile description.\n    \n    \n      source_userid\n      account from where the profiles should be listed. Only accounts with administration or customer_admin rights can use this field.\n    \n  \n Examples: <code>    GET /rest/device-profiles?paged_results=true&amp;limit=100&amp;search_name=myprofile\n    GET /rest/device-profiles?get_schema=true\n</code> <code class=\"language-JSON\">    [\n        {\n            \"profile_uuid\": \"UUID-of-profile\",\n            \"profile_name\": \"name-of-profile\",\n            \"description\": \"text description of profile\",\n\n            \"shared_with_all_users\": false,\n            \"link_to_profile_uuid\": \"uuid-of-target-profile\"\n        }\n        , ...\n    ]\n</code> Get Specific Device Profile Accounts that have the can_list_device_profiles right can use the following REST command to access the content of a device profile. <code>    GET /rest/device-profiles/{UUID-of-device-profile}\n</code> If the account has the can_inspect_device_profiles right, the full device profile with all parameters is returned. If the account does not have the can_inspect_device_profiles right, the content object will return a minimal subset of the device profiles with just the following two parameters: The MACVersion field with a reduced version number (“1.0.x” or “1.1.x”) and the activation field with “ABP” or “OTAA”. These two fields allow an application to determine the key-scheme to use to for a device, even if the actual device profile is not visible. <code class=\"language-JSON\">{\n    \"description\": \"text description of profile\",\n    \"profile_name\": \"name-of-profile\",\n    \"content\":\n        {\n            \"activation\": \"OTAA\",\n            \"RFRegion\": \"EU868\",\n            \"MACVersion\": \"1.0.2\",\n            \"RegParamsRevision\": \"A\",\n            \"MaxEIRP\": 14,\n            \"DefaultDeviceClass\": \"CLASS_A\",\n            \"SupportsClassB\": true,\n            \"SupportsClassC\": true,\n            \"transmit_capable_only\": false,\n            \"lora_fcnt32bits\": true,\n            \"dl_max_size_app_payload\": 64,\n            \"dl_max_size_phy_payload\": 64,\n            \"dl_max_num_mac_cmd\": 3,\n            \"dl_max_size_mac_cmd\": 16,\n            \"support_fuota\": true,\n            \"mobile_device\": false,\n            \"persisted_fcnt\": \"AUTO\",\n            \"persistent_nonce_counters\": \"AUTO\",\n            \"factory_presets\": [\n                {\n                    \"RFRegion\": \"EU868\",\n                    \"MaxEIRP\": 14,\n                    \"ul_dwell_time\": 0,\n                    \"dl_dwell_time\": 0,\n                    \"adr_ack_limit\": 6,\n                    \"adr_ack_delay\": 5,\n                    \"max_time_between_rejoin_req\": 0,\n                    \"max_num_of_ul_between_rejoin_req\": 0,\n                    \"min_ul_dr_supported\": 0,\n                    \"max_ul_dr_supported\": 6,\n                    \"rx2_dr\": 2,\n                    \"rx2_freq_mhz\": 868,\n                    \"rx1_delay\": 1,\n                    \"rx1_dr_offset\": 0,\n                    \"ping_slot_freq_mhz\": 868,\n                    \"ping_slot_dr\": 0,\n                    \"ping_slot_periodicity\": 0,\n                    \"channels\": [\n                        {\n                            \"freq_mhz\": 0,\n                            \"dr_min\": 0,\n                            \"dr_max\": 0,\n                            \"masked\": false,\n                            \"dl_freq_mhz\": 433\n                        }\n                    ],\n                    \"mask_125khz\": \"FFFFFFFFFFFFFFFF\",\n                    \"mask_500khz\": \"FF\",\n                    \"freq_change_not_supported\": false\n                }\n            ]\n        }\n\n}\n</code> The reduced device profile (when the user either doesn’t have the can_inspect_device_profiles right, or the profile is a link and has the can_be_inspected field set false) will return the following object. <code class=\"language-JSON\">{\n    \"description\": \"text description of profile\",\n    \"profile_name\": \"name-of-profile\",\n    \"content\":\n        {\n            \"activation\": \"ABP\",\n            \"MACVersion\": \"1.0.x\"\n        }\n}\n</code> Note: when checking the MACVersion to determine the key scheme, ONLY the first three bytes of the version should be used (e.g. 1.0 or 1.1). The remaining part of the version should be discarded. If the profile is a link to another profile the field link_to_profile_uuid will contain the UUID of the linked profile. When the link_to_profile_uuid field is not present, it means the profile is not a link but a local profile. For a detailed description of the parameters, please see @sec:createDevProfile. Modify Device Profile Profiles can be modified using the following command: <code>    PUT /rest/device-profiles/{profile-UUID}\n</code> Only accounts that have can_create_device_profiles and/or can_link_device_profiles can use this API.\nThe PUT command take the same JSON object as the POST command (to create the profile). Please see the API for create device-profile for details on the JSON object. Note, that when modifying a profile, if any profile parameter (other than name and description) is modified, all the parameters must be provided. Device profiles once in use (i.e. have been assigned to a device) cannot be freely changed in the content part of the profile. If a PUT contains change to parameters that are not allowed to be changed, the command will fail with a 423 (locked) error. The following parameters are safe to change: <code>    \"content\": {\n        \"DefaultDeviceClass\",\n        \"SupportsClassB\",\n        \"SupportsClassC\",\n        \"transmit_capable_only\",\n        \"lora_fcnt32bits\",\n        \"dl_max_size_app_payload\",\n        \"dl_max_size_phy_payload\",\n        \"dl_max_num_mac_cmd\",\n        \"dl_max_size_mac_cmd\",\n        \"support_fuota\",\n        \"persisted_fcnt\",\n        \"mobile_device\"\n    }\n</code> Changing any of the other parameters not in the above list will cause the request to fail. Return values: \n  \n    \n      Status\n      Description\n    \n  \n  \n    \n      200\n      Device Profile created ok. return message contains above JSON object with created UUID.\n    \n    \n      400\n      Invalid profile definition. Inspect the returned text string for further clues about the reason for failure.\n    \n    \n      401\n      Unauthorized. Invalid account or password\n    \n    \n      403\n      Forbidden. The account does not have sufficient rights for the requested operation.\n    \n    \n      404\n      Profile not found.\n    \n    \n      423\n      Profile is locked for change on the affected parameters\n    \n  \n Delete Device Profile Profiles can be deleted using the following command: <code>    DELETE /rest/device-profiles/{profile-UUID}\n</code> Only accounts that has can_create_device_profiles and/or can_link_device_profiles can use this API. Return values: \n  \n    \n      Status\n      Description\n    \n  \n  \n    \n      200\n      Device Profile deleted ok.\n    \n    \n      401\n      Unauthorized. Invalid account or password\n    \n    \n      403\n      Forbidden. The account does not have sufficient rights for the requested operation.\n    \n    \n      404\n      The profile is not found\n    \n    \n      423\n      The profile is locked because it is referenced either by link or by device and cannot be deleted. Remove all reference to the profile before deleting it.\n    \n  \n","url":"rest.html","anchor":"device-profile"},{"objectID":"rest-api-service-profile","hierarchy_lvl0":"Documentation","hierarchy_lvl1":"REST API","hierarchy_lvl2":"Service Profile","content":" Service Profile This section described the API used to manage service-profiles. The following rights governs which service profile API an account can access. \n  can_list_service_profiles\n The following sections details all API and parameters for service profiles. List Service Profiles Accounts that have can_list_service_profiles rights can use the following REST commands to list the available devices profiles accessible by this account. <code>    GET /rest/service-profiles?[query-options]\n</code> The following query-options are available. \n  \n    \n      Query option\n      Description\n    \n  \n  \n    \n      get_pages\n      Get list of page links to be used with paged queries. See section “Paged Queries”.\n    \n    \n      limit\n      Set number of items per page. Used with paged queries. See section “Paged Queries”.\n    \n    \n      page_state\n      Set the page state to start the query from where the previous query finished or jump to any page returned by the get_pages option. See section “Paged Queries”.\n    \n    \n      paged_results\n      Return results in paged format. See section “Paged Queries”.\n    \n    \n      strict\n      Force strict parameter and options checking. Should be used during development only and not used in production code.\n    \n    \n      get_schema\n      Return the JSON schema used to define a service profile.\n    \n    \n      search_name\n      Return only profiles that match the search criteria on the profile name.\n    \n    \n      search_description\n      Return only profiles that match the search criteria on the profile description.\n    \n    \n      search_linked\n      set true or false to return only profiles that are linked or not linked\n    \n    \n      source_userid\n      account from where the profiles should be listed. Only accounts with administration or customer_admin rights can use this field.\n    \n  \n Examples: <code>    GET /rest/service-profiles?paged_results=true&amp;limit=100&amp;search_name=myprofile\n    GET /rest/service-profiles?get_schema=true\n</code> If successful the following JSON object is returned: <code class=\"language-JSON\">    [\n        {\n            \"profile_uuid\": \"UUID-of-profile\",\n            \"profile_name\": \"name-of-profile\",\n            \"description\": \"text description of profile\",\n\n            \"shared_with_all_users\": false,\n            \"link_to_profile_uuid\": \"uuid-of-target-profile\"\n        }\n        , ...\n    ]\n</code> \n  \n    \n      Status\n      Description\n    \n  \n  \n    \n      200\n      Query successful, list of profiles is being returned.\n    \n    \n      401\n      Unauthorized. Invalid account or password\n    \n    \n      403\n      Forbidden. The account does not have sufficient rights for the requested operation.\n    \n  \n Plugin Functions The DASS has support for inserting small Javascript functions to perform encoding of messages to customizable formats as well as decoder functions to decode the binary payload from a device and translate it into device agnostic data. The functions are provided in Javascript and the DASS will execute them when needed. As the functions are executed in real-time the DASS put some restrictions on what is allowed and in general the Javascript function must be short and fast to execute. The DASS will accumulate the time spent in a function and if the average time over a period exceed 0.1ms the function will be automatically disabled. The functions are executed in a “sandbox” which means the usage of library function inside the function is highly restricted.","url":"rest.html","anchor":"service-profile"},{"objectID":"rest-api-sec:payloadDecoderFunction","hierarchy_lvl0":"Documentation","hierarchy_lvl1":"REST API","hierarchy_lvl2":"Payload Decoding function","content":" Payload Decoding function A payload decoding function is used to translate the binary format of a device into a more device agnostic format. E.g. for a temperature sensor, the sensor may send the temperature readings in a binary format that will have to be converted into an actual message field called “temperature” with and value directly in degree centigrade (or any other unit). When a payload have been decoding in this way it is typically possible to forward the data directly to end applications that may not know the exact sensor used (and hence would not understand the binary payload format), but understand the generic “temperature” field and is able to process it. Note, the decode function is only called for devices that can be decrypted by the network, meaning the network must be able to access the AppSKey. To help expose the data to varies IoT platforms and frameworks, it is useful (and highly recommended) to provide also a model description of the output from the device. A model describe which parameters is available from the payload decoder. The model can be queried through the Graphite API on the DASS so that applications can ask device which kind of data is provided by the device. E.g. if the device is a temperature sensor it will typically provide the temperature. In this case the model would contain a parameter “temperature” of type “number” with an optional description. A payload decoding function can be assigned to a device function <code class=\"language-javascript\">model = {\n    temperature: \"number\",\n    color: \"string\",\n    open: \"boolean\"\n}\n\ndecoder = function (uplink, meta) {\n\n    const temp  = (uplink.data[0] + uplink.data[1] * 256) / 10;\n    const color = temp &gt; 30 ? \"red\" : \"green\";\n    const open  = uplink.data[2] == 1 ? true : false;\n\n    const output = {\n        json: {\n            temperature: temp,\n            color: color,\n            open: open\n        }\n    }\n\n    return output;\n}\n</code> The above javascript code must be provided in the payload_decoder_js field of a device profile as a properly JSON encoded/escaped string. The decoder function is called for each payload to decode. The function is called with the following arguments: <code class=\"language-javascript\">uplink: {\n    data: Buffer, // Buffer object from NodeJS\n    fport: 1,     // the port number\n    devaddr: 123, // the DevAddr of the device\n    fcnt: 2345    // the FCNT of the uplink\n}\n</code> The meta parameter has these fields: <code class=\"language-JS\">meta: {\n    freq: 868.1,        // received frequency\n    rssi: -102,         // RSSI from best received gateway\n    snr: 10,            // SNR from best received gateway\n    tags: {             // optional tags object on each device\n        \"user-tag-1\": \"value\"   //\n    },\n}\n</code> note; the object may have more fields - but presently the above fields are the only fields guaranteed to be there. External join servers Join Servers (JS) are an integral part of the LoraWAN eco system. A join server is responsible for storing the keys for devices and perform the processing of the JOIN procedure as well as to generate the “session” keys used for the message exchange between LNS and device. The OrbiWAN LNS has a builtin join server that will mange all these tasks automatically, but it requires that the root key of the device, the “AppKey” is provided on the OrbiWAN instance so as be able to manage the JOIN process. While this scheme in most cases is the most convenient, there are cases where the AppKey cannot be shared for security reasons. When the AppKey is provided to the LNS, the operator of the LNS will in principle be able to intercept the data from a device. In some use cases it is a requirement that the keys are not available to the operator and that the data can only be decrypted by the customers application. This mode is know as end-to-end encryption. In this case the AppKey has to be stored somewhere outside the LNS and the processing of the JOIN REQUEST and the key derivation has to be managed outside the LNS too. This is the job of an “external Join Server”. The Lora Alliance has standardized a “backend” interface for a LNS to contact a JS. A join server is identified by a Join Server EUI (JoinEUI) which is sent by the device during the JOIN REQUEST. The JoinEUI is formerly know as the AppEUI, and is used to tell the LNS which JS the LNS should contact to get the keys. As there is currently no standard way to find an actual join server from the JoinEUI, it is necessary to register the used join servers on OrbiWAN. Typically a JS will work on a large range of JoinEUI, not just a single EUI value. A join server can be used both “globally” meaning a device manufacturer may provide a global join servers that can by used with all the devices it has produced and have some mechanism for the customer to claim his or her devices. But a join server can also be “private” and used just with the customers own devices. Both usages are fully supported by OrbiWAN. Join Servers can be registered at two levels on OrbiWAN. A join server be be registered globally on the instance, and will serve request for all customers connected to the instance. But join servers can also be registered at the customer level account in the DASS, and will serve only devices that has been registered on the customer account or any of its user accounts. Each customer level account has its own join server registry. Whether customers are allowed to use their own registry or must rely on the global registry can be controlled by the operator by giving or not the can_register_joinserver right. When a (registered) device send the JOIN REQUEST, OrbiWAN will process it in the following way: <code class=\"language-mermaid{-s=1;-t=neutral,width=12cm}\">graph TD\n    join[Receive JOIN REQUEST] --&gt; process[Extract DevEUI and JoinEUI]\n    process --&gt; dev{Is the&lt;br&gt;DevEUI known} --No--&gt; ignore\n    dev --Yes--&gt; owner[Find owner account]\n    owner --&gt; keys{Is the AppKey&lt;br&gt;available}\n    keys --yes--&gt; proc[Built-in JS&lt;br&gt;Process Request] --&gt; send\n    keys --no--&gt; override[check if JoinEUI override set on device,&lt;br&gt;otherwise use JoinEUI from JOIN ACCEPT]\n    override --&gt; loc{is the JoinEUI&lt;br&gt;in range of JS&lt;br&gt;registered&lt;br&gt;on customer&lt;br&gt;account}\n    loc --yes--&gt; forw1[Forward JOIN REQUEST to JS] --&gt; ExtJS1[Ext JS&lt;br&gt;Process Request] --JOIN Accept and keys--&gt; send\n    loc --no--&gt; loc2{is the JoinEUI&lt;br&gt;in range of JS&lt;br&gt;registered&lt;br&gt;globally}\n    loc2 --yes--&gt; forw2[Forward JOIN REQUEST to JS] --&gt; ExtJS2[Ext JS&lt;br&gt;Process Request] --JOIN Accept and keys--&gt; send\n    loc2 --no--&gt; api[forward JOIN req to&lt;br&gt;application via join topic] --&gt; App[Application&lt;br&gt;process Request]\n    App --JOIN Accept and keys--&gt; send[Send JOIN ACCEPT&lt;br&gt;Store Session Keys]\n</code> As can be seen from the flow chart, when a registered device send a JOIN REQUEST and it is received by the OrbiWAN LNS, the devices is first checked and the owner identified. If the owner has registered the keys directly on OrbiWAN, the join will be automatically managed by the built-in Join Server. Subsequently the application payloads are also managed (encryption/decryption/fcnt) automatically. If the keys are not available, OrbiWAN will first check if the JoinEUI (AppEUI in the JOIN REQUEST) is inside a registered range under the customer account for which the device belong. If a Join Server is not found in the customer account Join Server registry, next the global registry will be searched. If found the JOIN REQUEST message will be forwarded to the JS and if accepted, the JS will return an encrypted JOIN ACCEPT message and the session keys. If a JS is not found, the DASS will forward the JOIN REQUEST to the application via the application push protocol. To support devices that does not have a proper JoinEUI/AppEUI value, for example old devices, a JoinEUI override feature exist allowing the device owner to set an JoinEUI override value that is used instead of the value sent in the JOIN REQUEST when finding the appropriate Join Server. Note, if a device belong to a user account the search for a join server will happen on the parent customer account of the user account. Join server EUI cannot be registered per user account, only per customer accounts. An account need to have can_register_joinserver rights to be able to register (or unregister) a join server. Any user or customer account with this right can register a JoinEUI range on the customer account. Only users with sys_admin (and can_register_joinserver) rights can register join servers globally for the entire network.","url":"rest.html","anchor":"sec:payloadDecoderFunction"},{"objectID":"rest-api-register-new-join-server-eui-range","hierarchy_lvl0":"Documentation","hierarchy_lvl1":"REST API","hierarchy_lvl2":"Register new Join Server EUI range","content":" Register new Join Server EUI range Register a external Join Server to an AppEUI (or JoinEUI) range. <code>URL: https://dass-host[:port] /rest/joinservers[?registry=customer|global] Method: POST \\ Direction: application-&gt;DASS\n</code> To register a new join server, either at customer level or globally. The following JSON must be provided: <code class=\"language-JSON\">{\n    \"name\": \"join-server name\",\n    \"joineui_range\": \"ffffff0000000000-ffffffffffffffff\",\n\n    \"ignore_joinserver_cert\": false,\n    \"joinserver_cert\": \"---joinserver certificate---\",\n    \"private_cert\": \"---private-certificate---\",\n    \"private_key\": \"---private-key---\",\n    \"type\": \"LWBE-1.0\",\n    \"url\": \"https://my.joinserver.com:1234/joinserver/callme\"\n}\n</code> \n  \n    \n      field\n      Description\n    \n  \n  \n    \n      name\n      Assigned name of the join server.\n    \n    \n      joineui_range\n      range of EUI values that are covered by the JOIN server. If only a single EUI is registered, the range can be specified as a single value without the hyphen.\n    \n    \n      ignore_joinserver_cert\n      Default is false. I the certificate of the join server cannot be verified the JOIN will fail. However for testing is may be convenient to ignore the certificate check. Should never be used for production setup.\n    \n    \n      joinserver_cert\n      The certificate of the Join server. If the join server certificate doesn’t match this certificate during the join request, the JOIN the connection will fail and the join will fail. Note: if the join server has a valid public certificate it is not necessary to provide the certificate.\n    \n    \n      private_cert\n      The certificate that OrbiWAN will use to make the request to the join server. It allow the join server to safely identify the OrbiWAN server and accept (or not) the request.\n    \n    \n      private_key\n      The private key to be used with the certificate.\n    \n    \n      type\n      The type of JOIN server. This used to identify the protocol to use. The supported types are: “LWBE-1.0” (LoraWAN backend spec), “LWBE-1.1”, “loracloud” and “gemalto”.\n    \n  \n The JoinEUI ranges may not overlap with other join server registered at the same level (i.e. on customer), but can overlap with other customers or with the global register. In case of overlap error 409 is returned. To select if the join server is added to the local customer registry or to the global registry, the query option “registry” must be set to customer (default) or global. Return values \n  \n    \n      Status value\n      Meaning\n      Description\n    \n  \n  \n    \n      200\n      OK\n      The join server was successfully registers and associated with the EUI range\n    \n    \n      400\n      Bad request\n      Something wrong with the JSON message. See return message for more info\n    \n    \n      401\n      Unauthorized\n      The username/password used in the basic authentication scheme is invalid or not present.\n    \n    \n      403\n      Forbidden\n       \n    \n    \n      409\n      Overlap\n      the EUI range overlap an existing range\n    \n  \n","url":"rest.html","anchor":"register-new-join-server-eui-range"},{"objectID":"rest-api-get-list-of-join-servers-joineui-ranges","hierarchy_lvl0":"Documentation","hierarchy_lvl1":"REST API","hierarchy_lvl2":"Get list of join servers JoinEUI ranges","content":" Get list of join servers JoinEUI ranges <code>URL: https://dass-host[:port] /rest/joinservers[?registry=customer|global] Method: GET \\ Direction: application-&gt;DASS\n</code> Get the list of join servers and JoinUI ranges from the join registry. Select the registry with the registry query parameter. Default is the customer registry. The list of join servers and JoinEUI ranges are return in the following way: <code class=\"language-JSON\">[\n    {\n        \"name\": \"join-server name\",\n        \"joineui_range\": \"ffffff0000000000-ffffffffffffffff\",\n\n        \"ignore_joinserver_cert\": false,\n        \"joinserver_cert\": \"---joinserver certificate---\",\n        \"private_cert\": \"---private-certificate---\",\n        \"private_key\": \"---private-key---\",\n        \"type\": \"loracloud\",\n        \"url\": \"https://my.joinserver.com:1234/joinserver/callme\"\n    },\n    ...\n]\n</code> \n  \n    \n      Status value\n      Meaning\n      Description\n    \n  \n  \n    \n      200\n      OK\n      The list of join servers is returned as shown above.\n    \n    \n      400\n      Bad request\n      Something wrong with the JSON message or the query options\n    \n    \n      401\n      Unauthorized\n      The username/password used in the basic authentication scheme is invalid or not present.\n    \n    \n      403\n      Forbidden\n      The account does not have permission to access this API or part of the API\n    \n  \n","url":"rest.html","anchor":"get-list-of-join-servers-joineui-ranges"},{"objectID":"rest-api-get-join-servers-details-for-joineui-ranges","hierarchy_lvl0":"Documentation","hierarchy_lvl1":"REST API","hierarchy_lvl2":"Get join servers details for JoinEUI ranges","content":" Get join servers details for JoinEUI ranges <code>URL: https://dass-host[:port] /rest/joinservers/{JoinEUI range}[?registry=customer|global] Method: GET \\ Direction: application-&gt;DASS\n</code> Get join server entry for a particular JoinEUI range. Example: <code>GET https://hostname/rest/joinservers/ffffff0000000000-ffffffffffffffff\n</code> The join servers details are returned in the following way: <code class=\"language-JSON\">{\n    \"name\": \"join-server name\",\n    \"joineui_range\": \"ffffff0000000000-ffffffffffffffff\",\n\n    \"ignore_joinserver_cert\": false,\n    \"joinserver_cert\": \"---joinserver certificate---\",\n    \"private_cert\": \"---private-certificate---\",\n    \"private_key\": \"---private-key---\",\n    \"type\": \"loracloud\",\n    \"url\": \"https://my.joinserver.com:1234/joinserver/callme\"\n},\n</code> \n  \n    \n      Status value\n      Meaning\n      Description\n    \n  \n  \n    \n      200\n      OK\n      The list of join servers is returned as shown above.\n    \n    \n      400\n      Bad request\n      Something wrong with the JSON message or the query options\n    \n    \n      401\n      Unauthorized\n      The username/password used in the basic authentication scheme is invalid or not present.\n    \n    \n      403\n      Forbidden\n      The account does not have permission to access this API or part of the API\n    \n    \n      404\n      Not Found\n      The join server range was not found.\n    \n  \n","url":"rest.html","anchor":"get-join-servers-details-for-joineui-ranges"},{"objectID":"rest-api-delete-join-server-joineui-range","hierarchy_lvl0":"Documentation","hierarchy_lvl1":"REST API","hierarchy_lvl2":"Delete join server JoinEUI range","content":" Delete join server JoinEUI range <code>URL: https://dass-host[:port] /rest/joinservers/{joineui-range}[?registry=customer|global] Method: DELETE \\ Direction: application-&gt;DASS\n</code> Delete a join server. The join server is identified by its JoinEUI range. The query parameter registry determine the registry from where the join server is deleted. Example <code>DELETE https://hostname/rest/joinservers/ffffff0000000000-ffffffffffffffff\n</code> \n  \n    \n      Status value\n      Meaning\n      Description\n    \n  \n  \n    \n      200\n      OK\n      The join server was deleted and the JoinEUI range was removed from the registry.\n    \n    \n      400\n      Bad request\n       \n    \n    \n      401\n      Unauthorized\n      The username/password used in the basic authentication scheme is invalid or not present.\n    \n    \n      403\n      Forbidden\n      The account doesn’t have sufficient rights to delete a JoinEUI ranges.\n    \n  \n Misc API","url":"rest.html","anchor":"delete-join-server-joineui-range"},{"objectID":"rest-api-graphite-api","hierarchy_lvl0":"Documentation","hierarchy_lvl1":"REST API","hierarchy_lvl2":"Graphite API","content":" Graphite API The DASS support a subset of the Graphite API (https://graphite-api.readthedocs.io/en/latest/). This API is well supported by varies Dashboard tools such as Grafana, and by using this API it is easy to connect a Dashboard directly to the DASS and show varies graphs without customizing any tool. It should be noted the exposed API is a subset only and not all features of the API is available. The Graphite API expose two endpoints: <code>GET /api/graphite/metrics/find\nPOST /api/graphite/render\n</code> They are explained in the following sections Graphite - Find API The find API is used for device and parameter discovery. Tools such as Grafana can query on this API to see which devices are available and which particular parameters can be access on the devices. This make it easy to build a dashboard as all available information is presented directly in the tool. The API is used in the following way: GET /api/graphite/metrics/find?query=search-path&amp;[format=json] Where search-path is used to narrow the search. Initially putting the search-path to ‘*’ will cause the API to return a list of available devices. Asterisk (‘*’) wildcards can be used to narrow the search. Example: <code>    GET /api/graphite/metrics/find?query=70b3*\n</code> returns e.g.: <code class=\"language-JSON\">[\n  {\n    \"text\": \"70b3d507800008e8\",\n    \"id\": \"70b3d507800008e8\",\n    \"expandable\": 1,\n    \"leaf\": 0,\n    \"allowChildren\": 0\n  },\n  {\n    \"text\": \"70b3d507800008e9\",\n    \"id\": \"70b3d507800008e9\",\n    \"expandable\": 1,\n    \"leaf\": 0,\n    \"allowChildren\": 0\n  }\n]\n</code> Once a devices have been selected it is provided again to the API followed by a period (‘.’) and another ampersand. This will return a list of available parameters: <code>    GET /api/graphite/metrics/find?query=70b3d507800008e8.*\n</code> This returns: <code class=\"language-JSON\">[\n  {\n    \"text\": \"info\",\n    \"id\": \"70b3d507800008e8.info\",\n    \"expandable\": 1,\n    \"leaf\": 1,\n    \"allowChildren\": 0\n  },\n  {\n    \"text\": \"timeseries\",\n    \"id\": \"70b3d507800008e8.timeseries\",\n    \"expandable\": 1,\n    \"leaf\": 1,\n    \"allowChildren\": 0\n  }\n]\n</code> The format of the JSON is in “json” format type of the Graphite find API. As can be seen, there are two groups of properties on a devices, info and timeseries. When expandable is 1 it means they have additional fields and can be be further explored: <code>    GET /api/graphite/metrics/find?query=70b3d507800008e8.info.*\n</code> returns: <code class=\"language-JSON\">[\n  {\n    \"text\": \"comment\",\n    \"id\": \"70b3d507800008e8.info.comment\",\n    \"expandable\": 0,  \"leaf\": 1,  \"allowChildren\": 0\n  },\n  {\n    \"text\": \"location\",\n    \"id\": \"70b3d507800008e8.info.location\",\n    \"expandable\": 0,  \"leaf\": 1,  \"allowChildren\": 0\n  },\n  {\n    \"text\": \"dlfcnt\",\n    \"id\": \"70b3d507800008e8.info.dlfcnt\",\n    \"expandable\": 0,  \"leaf\": 1,  \"allowChildren\": 0\n  },\n  {\n    \"text\": \"device_class\",\n    \"id\": \"70b3d507800008e8.info.device_class\",\n    \"expandable\": 0,  \"leaf\": 1,  \"allowChildren\": 0\n  },\n  {\n    \"text\": \"deveui\",\n    \"id\": \"70b3d507800008e8.info.deveui\",\n    \"expandable\": 0,  \"leaf\": 1,  \"allowChildren\": 0\n  },\n  {\n    \"text\": \"latitude\",\n    \"id\": \"70b3d507800008e8.info.latitude\",\n    \"expandable\": 0,  \"leaf\": 1,  \"allowChildren\": 0\n  },\n  {\n    \"text\": \"longitude\",\n    \"id\": \"70b3d507800008e8.info.longitude\",\n    \"expandable\": 0,  \"leaf\": 1,  \"allowChildren\": 0\n  }\n]\n</code> and <code>    GET /api/graphite/metrics/find?query=70b3d507800008e8.timeseries.*\n</code> <code class=\"language-JSON\">[\n  {\n    \"text\": \"fcnt\",\n    \"id\": \"70b3d507800008e8.timeseries.fcnt\",\n    \"expandable\": 0,  \"leaf\": 1,  \"allowChildren\": 0\n  },\n  {\n    \"text\": \"rssi\",\n    \"id\": \"70b3d507800008e8.timeseries.rssi\",\n    \"expandable\": 0,  \"leaf\": 1,  \"allowChildren\": 0\n  },\n  {\n    \"text\": \"freq\",\n    \"id\": \"70b3d507800008e8.timeseries.freq\",\n    \"expandable\": 0,  \"leaf\": 1,  \"allowChildren\": 0\n  },\n  {\n    \"text\": \"snr\",\n    \"id\": \"70b3d507800008e8.timeseries.snr\",\n    \"expandable\": 0,  \"leaf\": 1,  \"allowChildren\": 0\n  },\n  {\n    \"text\": \"sf_used\",\n    \"id\": \"70b3d507800008e8.timeseries.sf_used\",\n    \"expandable\": 0,  \"leaf\": 1,  \"allowChildren\": 0\n  },\n  {\n    \"text\": \"port\",\n    \"id\": \"70b3d507800008e8.timeseries.port\",\n    \"expandable\": 0,  \"leaf\": 1,  \"allowChildren\": 0\n  },\n  {\n    \"text\": \"latitude\",\n    \"id\": \"70b3d507800008e8.timeseries.latitude\",\n    \"expandable\": 0,  \"leaf\": 1,  \"allowChildren\": 0\n  },\n  {\n    \"text\": \"longitude\",\n    \"id\": \"70b3d507800008e8.timeseries.longitude\",\n    \"expandable\": 0,  \"leaf\": 1,  \"allowChildren\": 0\n  },\n  {\n    \"text\": \"decoded\",\n    \"id\": \"70b3d507800008e8.timeseries.decoded\",\n    \"expandable\": 1,  \"leaf\": 1,  \"allowChildren\": 0\n  }\n]\n</code> The last element of the timeseries is the decoded object. This element can also be inspected and will return the available decoded parameters from an associated payload decoder. The elements available here are the ones specified in the model object in the payload decoder (see @sec:payloadDecoderFunction on plugin function for the payload decoder). Example: <code>    GET /api/graphite/metrics/find?query=70b3d507800008e8.timeseries.decoded.*\n</code> will return the parameters of the payload decoder model, e.g.: <code class=\"language-JSON\">[\n  {\n    \"text\": \"temperature\",\n    \"id\": \"70b3d507800008e8.timeseries.decoded.temperature\",\n    \"expandable\": 0,  \"leaf\": 1,  \"allowChildren\": 0\n  },\n  {\n    \"text\": \"humidity\",\n    \"id\": \"70b3d507800008e8.timeseries.decoded.humidity\",\n    \"expandable\": 0,  \"leaf\": 1,  \"allowChildren\": 0\n  }\n]\n</code> Note, that the exposed fields are shown above may change in future release. More fields may be added, and the queries will automatically return these new fields. Graphite - Render API The render API is used to return the values for the parameters found with the Find API described above. It is used in this way: <code>    POST /api/graphite/render\n    Content-Type: application/x-www-form-urlencoded\n\n    target=471ABD910019003D.timeseries.decoded.temperature&amp;\n    target=70b3d507800008e9.timeseries.decoded.humidity&amp;\n    from=-24h&amp;until=now&amp;format=json\n</code> Note, a valid from/until range should always be provided. It will return: <code class=\"language-JSON\">[\n  {\n    \"target\": \"temperature\",\n    \"datapoints\": [\n      [\n        19.5,\n        1553693923\n      ],\n      [\n        19.6,\n        1553694664\n      ],\n      ...\n    ]\n  }, {\n    \"target\": \"humidity\",\n    \"datapoints\": [\n      [\n        25,\n        1553693923\n      ],\n      [\n        25,\n        1553694664\n      ],\n      ...\n    ]\n  }\n]\n</code> Geo-location Solver","url":"rest.html","anchor":"graphite-api"},{"objectID":"rest-api-using-an-external-geo-location-solver","hierarchy_lvl0":"Documentation","hierarchy_lvl1":"REST API","hierarchy_lvl2":"Using an external Geo-location Solver","content":" Using an external Geo-location Solver By default OrbiWAN use it own embedded TDOA based geo location solver. However it is possible to use 3rd external solvers as part of the normal message flow. The external solver must support the LoraCloud / Collos v2 tdoaMultiframe format. The v2 TDOA-Multiframe format is specified here: https://www.loracloud.com/documentation/geolocation?url=v2.html#tdoa-multiframe-request To configure the system to use the external solver, the destination for the solver must be specified on the account. It can be specified either on the user account owning the device but can also be specified on an application sub-account in case different solvers are used for different devices. Note: for each device only one solver will be called. To specify the solver a dedicated tags “geosolver_url” must be assigned to the account. See @sec:customTags for more information about tags and keyword substitution. Once the geosolver_url tag is present OrbiWAN will forward the geolocation solve request to the solver at the URL. Often the solver will need some additional account information to authenticate the user. Typically this requires additional header fields to be added to the HTTP request. These additional HTTP header fields can be added by adding additional tags prefixed with “geosolver_header_” followed by the name of the actual header field, e.g. “geosolver_header_MyHeader”: “my-content” will add to the HTTP header of the solver request “MyHeader: my-content”. I.e.: <code class=\"language-JSON\">\"tags\": {\n    \"geosolver_url\": \"https://my-solver-host/\",\n    \"geosolver_header_my-header-1\": \"content-for-my-header-1\",\n    \"geosolver_header_my-header-2\": \"content-for-my-header-2\",\n}\n</code> Example LoraCloud To configure the solver on a users main account to use the Semtech LoraCloud (previously Collos) the following tags must be set: PUT https://{instance}/rest/user <code class=\"language-JSON\">\"tags\": {\n    \"geosolver_url\": \"https://gls.loracloud.com/api/v2/tdoaMultiframe\",\n    \"geosolver_header_Ocp-Apim-Subscription-Key\": \"my-loracloud-api-key\",\n}\n</code> The Ocp-Apim-Subscription-Key is the custom header required by LoraCloud to access the API. The key must be requested on the LoraCloud.com website.","url":"rest.html","anchor":"using-an-external-geo-location-solver"},{"objectID":"production-best-practices-security-overview","hierarchy_lvl0":"Documentation","hierarchy_lvl1":"Production Best Practices: Security","hierarchy_lvl2":"Overview","content":" Overview The term “production” refers to the stage in the software lifecycle when an application or API is generally available to its end-users or consumers. In contrast, in the “development” stage, you’re still actively writing and testing code, and the application is not open to external access. The corresponding system environments are known as production and development environments, respectively. Development and production environments are usually set up differently and have vastly different requirements. What’s fine in development may not be acceptable in production. For example, in a development environment you may want verbose logging of errors for debugging, while the same behavior can become a security concern in a production environment. And in development, you don’t need to worry about scalability, reliability, and performance, while those concerns become critical in production.","url":"security.html","anchor":"overview"}]